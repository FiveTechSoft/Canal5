#line 38 "\fwh\include\fivewin.ch"
      static bError
#line 219 "hbclass.ch"
DECLARE HBClass  New( cName AS STRING, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS OBJECT  Instance() AS OBJECT  AddClsMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC, n2 AS NUMERIC, n3 AS NUMERIC )  AddMultiClsData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING )  AddMultiData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC )  AddInLine( cName AS STRING, bBlock AS CODEBLOCK, nScope AS NUMERIC )  AddVirtual( cName AS STRING )
#line 79 "\fwh\include\fivewin.ch"
         EXTERNAL FW_GT











extern errorsys
#line 14 "source\app.prg"
static oApp, oTray, oIcon
static lThemed     := .F.
static lEnableUndo := .F.
static lFromUndo   := .F.
static lxPocketPC  := .F.
static hFreeImage
static nFreeInstance := 0
static oWndCode

function main( p1, p2, p3 )


   lTemas( .T. )

   oApp := TApp():New( p1, p2, p3, oIcon )

   oApp:oInspector := ListPropEx()
   Designer()




   oApp:oWnd:Activate(, oApp:oWnd:bLClicked, oApp:oWnd:bRClicked, oApp:oWnd:bMoved, oApp:oWnd:bResized, oApp:oWnd:bPainted, oApp:oWnd:bKeyDown, oApp:oWnd:bInit := { | Self | ( oTray := TTrayIcon():New( oApp:oWnd, oIcon, "#5", { || Designer() }, { | nRow, nCol | oApp:MenuTray( nRow, nCol, oTray ) } ) ) },,,,,,,,, {|| ( oTray:End(), oApp:SaveConfig(), .T. )},, oApp:oWnd:bLButtonUp )

return nil


function Aplicacion(); return oApp

function lTemas( lTemas )

if pcount() > 0
   lThemed := lTemas
endif

return lThemed


function EnableUndo() ; lEnableUndo := .T.  ; return 0
function DisableUndo(); lEnableUndo := .F.  ; return 0
function lMetoEnUndo()                      ; return lEnableUndo
function BeginFromUndo() ; lFromUndo := .T. ; return 0
function EndFromUndo()   ; lFromUndo := .F. ; return 0
function lFromUndo();                         return lFromUndo


_HB_CLASS TApp ; function TApp ( ... ) ; static s_oClass ; local nScope, oClass, oInstance ; if s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; begin sequence ; nScope := 1 ; ( ( nScope ) ) ; oClass := IIF(.F.,, HBClass():new( "TApp" , iif( .F., { }, { @HBObject() } ), @TApp() ) ) ;

 ; ;; _HB_MEMBER { p1, p2, p3 } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"p1", "p2", "p3"}, .F. )
; _HB_MEMBER { oWnd } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oWnd"}, .F. )
; _HB_MEMBER { oMenu } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oMenu"}, .F. )
; _HB_MEMBER { oBar } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oBar"}, .F. )
; _HB_MEMBER { oWndPrj } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oWndPrj"}, .F. )
; _HB_MEMBER { oProyecto } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oProyecto"}, .F. )
; _HB_MEMBER { oOutPut } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oOutPut"}, .F. )
; _HB_MEMBER { aProyectos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aProyectos"}, .F. )
; _HB_MEMBER { oSolucion } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oSolucion"}, .F. )
; _HB_MEMBER { oGestIDs } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oGestIDs"}, .F. )
; _HB_MEMBER { oWndInspect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oWndInspect"}, .F. )
; _HB_MEMBER { oInspector } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oInspector"}, .F. )
; _HB_MEMBER { oCbxControles } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oCbxControles"}, .F. )
; _HB_MEMBER { oToolBox } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oToolBox"}, .F. )
; _HB_MEMBER { AS LOGICAL lCerrarToolBox } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCerrarToolBox"}, .F. )
; _HB_MEMBER { nState } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nState"}, .F. )
; _HB_MEMBER { oDFocus } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDFocus"}, .F. )
; _HB_MEMBER { oImgFocus } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oImgFocus"}, .F. )
; _HB_MEMBER { oWndFindFiles } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oWndFindFiles"}, .F. )
; _HB_MEMBER { oWndViewDbfs } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oWndViewDbfs"}, .F. )
; _HB_MEMBER { oWndViewImgs } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oWndViewImgs"}, .F. )
; _HB_MEMBER { oWndVisores } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oWndVisores"}, .F. )
 ; ; ;; _HB_MEMBER { nTop, nLeft, nBottom, nRight } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTop", "nLeft", "nBottom", "nRight"}, .F. )
 ;; _HB_MEMBER { nTopForm, nLeftForm } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTopForm", "nLeftForm"}, .F. )
 ; ; ;; _HB_MEMBER { nTopTool, nLeftTool, nBottomTool, nRightTool } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTopTool", "nLeftTool", "nBottomTool", "nRightTool"}, .F. )
 ; ; ;; _HB_MEMBER { nTopProp, nLeftProp, nBottomProp, nRightProp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTopProp", "nLeftProp", "nBottomProp", "nRightProp"}, .F. )


      _HB_MEMBER New() AS CLASS TApp; oClass:AddMethod( "New", @TApp_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Activate(); oClass:AddMethod( "Activate", @TApp_Activate(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER End(); oClass:AddInline( "End", {|Self | ( ( Self ) ), ::oWnd:End() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER Nuevo(); oClass:AddMethod( "Nuevo", @TApp_Nuevo(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER NuevoFile( cType); oClass:AddMethod( "NuevoFile", @TApp_NuevoFile(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER NuevoProyecto( nProyecto, cName, cLocation); oClass:AddMethod( "NuevoProyecto", @TApp_NuevoProyecto(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER CurDir(); oClass:AddInline( "CurDir", {|Self | ( ( Self ) ), CurDrive() + ":" + If( Empty( CurDir() ), "", "\" + CurDir() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER LastDir(); oClass:AddInline( "LastDir", {|Self | ( ( Self ) ), ::CurDir() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Menu(); oClass:AddMethod( "Menu", @TApp_Menu(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Barra(); oClass:AddMethod( "Barra", @TApp_Barra(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Abrir(); oClass:AddMethod( "Abrir", @TApp_Abrir(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Ftp(); oClass:AddMethod( "Ftp", @TApp_Ftp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Incrustar( nHelp); oClass:AddMethod( "Incrustar", @TApp_Incrustar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER SavePrj( cFileName); oClass:AddMethod( "SavePrj", @TApp_SavePrj(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER LoadPrj( cFileName); oClass:AddMethod( "LoadPrj", @TApp_LoadPrj(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER MainReSize( nMode); oClass:AddMethod( "MainReSize", @TApp_MainReSize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER MenuTray( nRow, nCol, oTray); oClass:AddMethod( "MenuTray", @TApp_MenuTray(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Parametros(); oClass:AddMethod( "Parametros", @TApp_Parametros(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER ValidaNombreProy( oNombre, oPath); oClass:AddMethod( "ValidaNombreProy", @TApp_ValidaNombreProy(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER GenCode(); oClass:AddMethod( "GenCode", @TApp_GenCode(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER LoadConfig(); oClass:AddMethod( "LoadConfig", @TApp_LoadConfig(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER SaveConfig(); oClass:AddMethod( "SaveConfig", @TApp_SaveConfig(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; oInstance := oClass:Instance() ; if __ObjHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; end ; always ; __clsUnlockDef( @s_oClass, oClass ) ; end ; return oInstance ; end ; return s_oClass:Instance() AS CLASS TApp ;


  static FUNCTION TApp_New( p1, p2, p3, oIcon ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


local o := self
local oBrush
local oMenu

p1 := "dsgn"

::p1 := p1
::p2 := p2
::p3 := p3

oIcon := TIcon():New( ,, "form",, )


  ::oWndInspect := nil
  ::aProyectos := {}

  ::LoadConfig()





  ::oWnd := TWindow():New( ::nTop, ::nLeft, ::nBottom, ::nRight, "Designer",,,, oIcon,,,,,,,, !.F., !.F., !.F., !.F., .T. )




       ::Barra()

       ::lCerrarToolBox := .F.
       ::nState := 0


return self


  static FUNCTION TApp_GenCode( ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp



return nil



  static FUNCTION TApp_SaveConfig( ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

 local oIni
 local cFile := ".\config.ini"
 local rc := GetWndRect(::oWnd:hWnd )
 local rc2
 local rc3 := {280, 600}
 local rc4

if Aplicacion():oToolBox <> nil
   rc2 := GetWndRect(Aplicacion():oToolBox:hWnd )
endif

      oIni := TIni():New( cFile )
         oIni:Set( "MainWindow", "Top", rc[1] )
         oIni:Set( "MainWindow", "Left", rc[2] )
         oIni:Set( "MainWindow", "Width", rc[4]-rc[2] )
         oIni:Set( "MainWindow", "Height", rc[3]-rc[1]-1 )

      if Aplicacion():oInspector <> nil
         rc4 := GetWndRect(Aplicacion():oInspector:hWnd )
         oIni:Set( "Inspector", "Top", rc4[1] )
         oIni:Set( "Inspector", "Left", rc4[2] )
         oIni:Set( "Inspector", "Bottom", rc4[3] )
         oIni:Set( "Inspector", "Right", rc4[4] )
      endif

      if Aplicacion():oToolBox <> nil
         oIni:Set( "ToolWindow", "Top", rc2[1] )
         oIni:Set( "ToolWindow", "Left", rc2[2] )
         oIni:Set( "ToolWindow", "Bottom", rc2[3] )
         oIni:Set( "ToolWindow", "Right", rc2[4] )
      endif

         oIni:Set( "FormWindow", "Top", rc3[1] )
         oIni:Set( "FormWindow", "Left", rc3[2] )


return 0


   static FUNCTION TApp_LoadConfig( ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

local oIni
local cIniFile := ".\config.ini"
local nTop    := 200
local nLeft   := 200
local nWidth  := 200
local nHeight := 55
local nRed, nGreen, nBlue
local rc2 := {100, 100, 873, 350}
local rc4 := {100, 100, 500, 400}
local rc3 := {280, 600}

    oIni := TIni():New( cIniFile )

        ::nTop := oIni:Get( "MainWindow", "Top", nTop, ::nTop )
        ::nLeft := oIni:Get( "MainWindow", "Left", nLeft, ::nLeft )
        nWidth := oIni:Get( "MainWindow", "Width", nWidth, nWidth )
        nHeight := oIni:Get( "MainWindow", "Height", nHeight, nHeight )

        ::nTopTool := oIni:Get( "ToolWindow", "Top", rc2[1], ::nTopTool )
        ::nLeftTool := oIni:Get( "ToolWindow", "Left", rc2[2], ::nLeftTool )
        ::nBottomTool := oIni:Get( "ToolWindow", "Bottom", rc2[3], ::nBottomTool )
        ::nRightTool := oIni:Get( "ToolWindow", "Right", rc2[4], ::nRightTool )

        ::nTopProp := oIni:Get( "Inspector", "Top", rc4[1], ::nTopProp )
        ::nLeftProp := oIni:Get( "Inspector", "Left", rc4[2], ::nLeftProp )
        ::nBottomProp := oIni:Get( "Inspector", "Bottom", rc4[3], ::nBottomProp )
        ::nRightProp := oIni:Get( "Inspector", "Right", rc4[4], ::nRightProp )


        ::nTopForm := oIni:Get( "FormWindow", "Top", rc3[1], ::nTopForm )
        ::nLeftForm := oIni:Get( "FormWindow", "Left", rc3[2], ::nLeftForm )




    ::nBottom := ::nTop + nHeight
    ::nRight  := ::nLeft + nWidth



return 0



  static FUNCTION TApp_MainReSize( nMode ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

   local rc := GetClientRect(::oWnd:hWnd)

   If( nMode == nil, nMode := 0, ) ;

   do case
      case nMode == 1

           if ::oWndInspect <> nil
              ::oWndInspect:Hide()
           endif

      case nMode == 2

           if ::oWndInspect <> nil
              ::oWndInspect:Show()
           endif

      case nMode == 0

           if ::oWndInspect <> nil
              ::oWndInspect:Show()
           endif

   endcase


return nil



  static FUNCTION TApp_Activate( ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


local oIcon, oIcon1
local o := self

oIcon := TIcon():New( ,, "dialogo",, )
oIcon1 := TIcon():New( ,, "icon",, )

::oWnd:Activate( Upper("MAXIMIZED"), ::oWnd:bLClicked, ::oWnd:bRClicked, ::oWnd:bMoved, ::oWnd:bResized, ::oWnd:bPainted, ::oWnd:bKeyDown, ::oWnd:bInit,,,,,,,,, {|| (o:lCerrarToolBox := .T., .T.)},, ::oWnd:bLButtonUp )





return nil


  static FUNCTION TApp_Parametros( ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


if ::p1 <> nil
   do case
      case ::p1 == "spy"
           ShowDatos()

      case ::p1 == "findfiles"
           FindInFiles( 1 )

      case ::p1 == "img"
           WndFold()

           Aplicacion():oToolBox:cargo:cargo[1]:SetOption( 4 )
           ImageEditor()

      case ::p1 == "dsgn"
           WndFold()


           designer()


   endcase
endif

return nil



  static FUNCTION TApp_MenuTray( nRow, nCol, oTray ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


LOCAL oMenu
local o := self

   oMenu := MenuBegin( .T.,,, .F., .F. )
      MenuAddItem( "Spy",, .F.,, {|oMenuItem|Showdatos()},,,,,,, .F.,,, .F. )
      MenuAddItem( "Designer",, .F.,, {|oMenuItem|Designer()},,,,,,, .F.,,, .F. )
      MenuAddItem( "Show",, .F.,, {|oMenuItem|o:oWnd:Show()},,,,,,, .F.,,, .F. )
      MenuAddItem( "Hide",, .F.,, {|oMenuItem|o:oWnd:Show()},,,,,,, .F.,,, .F. )
      MenuAddItem( "Capturar",, .F.,, {|oMenuItem|CapturaRect()},,,,,,, .F.,,, .F. )

      MenuAddItem()
      MenuAddItem( "Close Application",, .F.,, {|oMenuItem|o:end()},,,,,,, .F.,,, .F. )
   MenuEnd()

   oMenu:Activate( nRow-10, nCol+10, oTray:oWnd, ! .F., )

RETURN NIL


  static FUNCTION TApp_Menu( ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


local oMenu

oMenu := MenuBegin( .F.,,, .F., .F. )


   MenuAddItem( "&Fichero",, .F.,,,,,,,,, .F.,,, .F. )
   MenuBegin( .F.,,, .F., .F. )
      MenuAddItem( "Nuevo",, .F.,,,,,,,,, .F.,,, .F. )
      MenuBegin( .F.,,, .F., .F. )
       MenuAddItem( "Formulario",, .F.,, {|oMenuItem|Designer()},,,,,,, .F.,,, .F. )
       MenuAddItem( "Ventanas",, .F.,,,,,,,,, .F.,,, .F. )


         MenuAddItem( "Formulario",, .F.,, {|oMenuItem|Designer()},,,,,,, .F.,,, .F. )

      MenuEnd()
      MenuAddItem( "Abrir",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Cerrar",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Añadir nuevo item...",, .F.,, {|oMenuItem|::Nuevo()},,,,,,, .F.,,, .F. )
      MenuAddItem( "Añadir existente item...",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Añadir proyecto",, .F.,,,,,,,,, .F.,,, .F. )
      MenuBegin( .F.,,, .F., .F. )
         MenuAddItem( "Nuevo proyecto",, .F.,,,,,,,,, .F.,,, .F. )
         MenuAddItem( "Existente proyecto",, .F.,,,,,,,,, .F.,,, .F. )
      MenuEnd()
      MenuAddItem( "Salvar",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Salvar como...",, .F.,, {|oMenuItem|::GenCode()},,,,,,, .F.,,, .F. )
      MenuAddItem( "Salvar todo",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Configurar página...",, .F.,, {|oMenuItem|PrinterSetup()},,,,,,, .F.,,, .F. )
      MenuAddItem( "Imprimir",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Recientes proyectos",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Salir",, .F.,, {|oMenuItem|oApp:End()},,,,,,, .F.,,, .F. )
   MenuEnd()
   MenuAddItem( "Edición",, .F.,,,,,,,,, .F.,,, .F. )
   MenuBegin( .F.,,, .F., .F. )
      MenuAddItem( "Undo",, .F.,, {|oMenuItem|if( ::oWnd:oWndActive <> nil, if( ::oWnd:oWndActive:bUndo  <> nil, eval( ::oWnd:oWndActive:bUndo ),),)},,,,,,, .F.,,, .F. )
      MenuAddItem( "Redo",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Cortar",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Copiar",, .F.,, {|oMenuItem|if( ::oWnd:oWndActive <> nil, if( ::oWnd:oWndActive:bCopy  <> nil, eval( ::oWnd:oWndActive:bCopy ),),)},,,,,,, .F.,,, .F. )
      MenuAddItem( "Pegar",, .F.,, {|oMenuItem|if( ::oWnd:oWndActive <> nil, if( ::oWnd:oWndActive:bPaste <> nil, eval( ::oWnd:oWndActive:bPaste ),),)},,,,,,, .F.,,, .F. )
      MenuAddItem( "Borrar",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Seleccionar todos",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Buscar y Reemplazar",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Ir a",, .F.,,,,,,,,, .F.,,, .F. )
   MenuEnd()
   MenuAddItem( "Proyecto",, .F.,,,,,,,,, .F.,,, .F. )
   MenuBegin( .F.,,, .F., .F. )
      MenuAddItem( "Añadir Clase...",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Añadir Recurso...",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Añadir nuevo elemento...",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Apadir existente elemento...",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Nueva carpeta",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Poner proyecto activo",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Propiedades...",, .F.,, {|oMenuItem|WndFold()},,,,,,, .F.,,, .F. )
   MenuEnd()
   MenuAddItem( "Construir",, .F.,,,,,,,,, .F.,,, .F. )
   MenuBegin( .F.,,, .F., .F. )
      MenuAddItem( "Construir",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Reconstruir",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Limpiar",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Configuración",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Compilar"           + chr(9) + "Ctrl+F7",, .F.,,,,,,,,, .F.,,, .F. )
   MenuEnd()
   MenuAddItem( "Debug",, .F.,,,,,,,,, .F.,,, .F. )
   MenuBegin( .F.,,, .F., .F. )
      MenuAddItem( "Ventanas",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Ejecutar"           + chr(9) + "F5",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Ejecutar sin debug" + chr(9) + "Ctrl+F5",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Entrar"             + chr(9) + "F11",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Paso a paso"        + chr(9) + "F10",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem()
      MenuAddItem( "Nuevo Breakpoint"   + chr(9) + "Ctrl+B",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Borrar todos BreakPoints"  + chr(9) + "Ctrl+Shift+F9",, .F.,,,,,,,,, .F.,,, .F. )
   MenuEnd()
   MenuAddItem( "Herramientas",, .F.,,,,,,,,, .F.,,, .F. )
   MenuBegin( .F.,,, .F., .F. )
      MenuAddItem( "Spy",, .F.,, {|oMenuItem|WinExec( "WinSpy.exe" )},,,,,,, .F.,,, .F. )
      MenuAddItem( "Documentar",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Visor Dbfs",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Macros",, .F.,,,,,,,,, .F.,,, .F. )
   MenuEnd()
   MenuAddItem( "Ventana",, .F.,,,,,,,,, .F.,,, .F. )
   MenuBegin( .F.,,, .F., .F. )
      MenuAddItem( "Nueva ventana",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Split",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Mosáico horizontal",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Mosáico vertical",, .F.,,,,,,,,, .F.,,, .F. )
      MenuAddItem( "Cascada",, .F.,,,,,,,,, .F.,,, .F. )
   MenuEnd()
MenuEnd()


return oMenu





  static FUNCTION TApp_Barra( ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

local oNuevo
local oMenuNuevo
local oMenuAdd
local o27

oMenuNuevo := MenuBegin( .T.,,, .F., .F. )
   MenuAddItem( "Nuevo proyecto",, .F.,, {|oMenuItem|Aplicacion():NuevoProyecto()},, "nuevo",,,,, .F.,,, .F. )
   MenuAddItem( "Prg",, .F.,, {|oMenuItem|NuevoCode()},, "source",,,,, .F.,,, .F. )
   MenuAddItem( "ch",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "C",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "h",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "Clase",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "Ventana",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "Diálogo",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "Menú",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "Imágen",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "Icono",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "RC",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "String Table",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "DBF",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "Indice",, .F.,,,, "",,,,, .F.,,, .F. )
   MenuAddItem( "Documentar",, .F.,,,, "",,,,, .F.,,, .F. )
MenuEnd()

oMenuAdd := MenuBegin( .T.,,, .F., .F. )
   MenuAddItem( "Añadir nuevo item...",, .F.,,,, "newitem",,,,, .F.,,, .F. )
   MenuAddItem( "Añadir item existente...",, .F.,,,, "item",,,,, .F.,,, .F. )
   MenuAddItem( "Añadir Clase",, .F.,,,, "class",,,,, .F.,,, .F. )
MenuEnd()


 ::oBar := LOOK2007 := TBar():New( ::oWnd, 28, 30, .T.,,, .F., .F. )



















      TBtnBmp():NewBar( "dialog",,,,, {|This|Designer()}, .F., ::oBar, .F.,, "F11 - Editor dialogos", .F.,, "Designer()",,,,,, !.T.,,,,, .F. )
      TBtnBmp():NewBar( "save",,,,,, .F., ::oBar, .F.,,, .F.,,,,,,,, !.T.,,,,, .F. )
      TBtnBmp():NewBar( "start",,,,,, .F., ::oBar, .F.,,, .F.,,,,,,,, !.T.,,,,, .F. )
      TBtnBmp():NewBar( "spy",,,,, {|This|ShowDatos()}, .F., ::oBar, .F.,,, .F.,, "ShowDatos()",,,,,, !.T.,,,,, .F. )
      TBtnBmp():NewBar( "spy",,,,, {|This|CapturaRect()}, .F., ::oBar, .F.,,, .F.,, "CapturaRect()",,,,,, !.T.,,,,, .F. )
































return 0

function RefreshWnds()
local n
local nW, nH

for n := 1 to len( Aplicacion():oWnd:oWndClient:aWnd )
    nW := Aplicacion():oWnd:oWndClient:aWnd[n]:nWidth
    nH := Aplicacion():oWnd:oWndClient:aWnd[n]:nHeight
    Aplicacion():oWnd:oWndClient:aWnd[n]:SetSize( nW+1, nH,.T.)
    Aplicacion():oWnd:oWndClient:aWnd[n]:SetSize( nW  , nH,.T.)
next

return 0













  static FUNCTION TApp_Nuevo( oTreeItem, lAddPrj ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

local o := self
local oDlg
local oFolder
local oListview, oName, oLoca, oAdd, oChk
local oListview2
local lAdd
local cName := space(100)
local cLoca := space(255)
local cAux
local oImageList
local nStyle := nOr(0x0020, 0x0001)
local oI1, oI2, oI3, oI4, oI5, oI6, oI7, oI8
local nOpcion := 0
local cFile
local oFile
local cCarpeta := ""
local lOk := .F.
local oK, oHelp, oCancel
local nProyecto

if oTreeItem <> nil
   cCarpeta := oTreeItem:cPrompt
endif

If( lAddPrj == nil, lAddPrj := .F., ) ;




if !empty( cCarpeta )
   cCarpeta := alltrim( cCarpeta )
   do case
      case cCarpeta == "Prgs"
           oFile := ::NuevoFile( "prg", .F. )
           return oTreeItem:Add( oFile:cFileName, 3, "prg" )
      case cCarpeta == "Chs" .OR. cCarpeta == "h"
           return ::NuevoFile( "h" )
      case cCarpeta == "Imagenes"
           return ::NuevoFile( "bmp")
   endcase
endif



lAdd := lAddPrj

oImageList =  TImageList():New(16,16,"toolbar\image1.bmp")

oDlg = TDialog():New(,,,,, "NUEVO",, .F.,,,,,, .F.,,,,,, .F., )



    oFolder := TFolder():ReDefine( 110, {"Proyecto","Fichero"}, { "NEWFILE","NEWFILE" }, oDlg,,,,, .F., )


       oListview := TListView():Redefine( 101, oFolder:aDialogs[1], )
       oChk := TCheckBox():ReDefine( 102, { | u | If( PCount()==0, lAdd, lAdd:= u ) }, oFolder:aDialogs[1],,,,,,, .F.,, )
       oName := TGet():ReDefine( 103, { | u | If( PCount()==0, cName, cName:= u ) }, oFolder:aDialogs[1],,,,,,,,, .F.,,, .F., .F.,,,,,,, "cName", )
       oLoca := TGet():ReDefine( 104, { | u | If( PCount()==0, cLoca, cLoca:= u ) }, oFolder:aDialogs[1],,,,,,,,, .F.,,, .F., .F.,,,,,,, "cLoca", )
       oAdd := TButton():ReDefine( 105, {||( nOpcion := oListView:nOption, cAux := cGetFolder("Seleccione un directorio", ::LastDir() ), if( !empty( cAux ), ( cLoca := cAux, oLoca:Refresh()), ) )}, oFolder:aDialogs[1],,, .F.,,,, .F. )

       oListview2 := TListView():Redefine( 101, oFolder:aDialogs[2], )


   oHelp := TButton():ReDefine( 3, {||MsgInfo("Help")}, oDlg,,, .F.,,,, .F. )
   oK := TButton():ReDefine( 1, {||if( o:ValidaNombreProy( oName, oLoca ),(lOk := .T., oDlg:End() ),.F.)}, oDlg,,, .F.,,,, .F. )
   oCancel := TButton():ReDefine( 2, {||oDlg:End()}, oDlg,,, .F.,,,, .F. )
























oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .T.,,, {|Self|( oChk:Hide(), oListView:SetImageList( oImageList,  1 ), oListView:InsertItem( 20, "Proyecto Consola" )    , oListView:InsertItem(  2, "Proyecto Windows" )    , oListView:InsertItem( 19, "Proyecto Pocket PC" )  , oListView:InsertItem( 11, "Librería" )            , oListView:InsertItem( 21, "Wizzard" )             , oListView2:SetImageList( oImageList,  1 ), oListView2:InsertItem(  3, "Prg"           ), oListView2:InsertItem(  1, "ch"            ), oListView2:InsertItem(  9, "C"             ), oListView2:InsertItem( 10, "h"             ), oListView2:InsertItem( 27, "Clase"         ), oListView2:InsertItem( 23, "Ventana"       ), oListView2:InsertItem( 23, "Diálogo"       ), oListView2:InsertItem( 24, "Menú"          ), oListView2:InsertItem( 26, "Imágen"        ), oListView2:InsertItem( 18, "Icono"         ), oListView2:InsertItem( 13, "RC"            ), oListView2:InsertItem(  3, "String Table"  ), oListView2:InsertItem(  4, "DBF"           ), oListView2:InsertItem( 22, "Indice"        ), oListView2:InsertItem( 25, "Documentar"    ))}, oDlg:bRClicked,,, )


if lOk

    do case
       case oFolder:nOption == 1
            do case
               case oListView:nOption == 1
                    nProyecto := 1
               case oListView:nOption == 2
                    nProyecto := 2
               case oListView:nOption == 3
                    nProyecto := PPC_PRJ
               case oListView:nOption == 4
                    nProyecto := 4
               case oListView:nOption == 5
                    nProyecto := 5
               otherwise
                    nProyecto := 2
            endcase

            ::NuevoProyecto( nProyecto, cName, cLoca )

       case oFolder:nOption == 2



    endcase


    if nOpcion == 0
       return nil
    endif

endif

return 0




  static FUNCTION TApp_ValidaNombreProy( oNombre, oPath ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


 if empty( oNombre:VarGet() )
    MsgAlert( "No se puede dejar vacío el nombre del proyecto")
    oNombre:SetFocus()
    return .F.
 endif

 if empty(oPath:VarGet())
    MsgAlert( "No se puede dejar vacío la ruta del proyecto")
    oPath:SetFocus()
    return .F.
 endif
 if !file( oPath:VarGet()+"\"+"nul.ext" )
    if !MsgYesNo( "No existe el diretorio. ¿Desea crearlo?" )
       oPath:SetFocus()
       return .F.
    else
       WQout( { "Crear directorio" } )
    endif
 endif

 if file( oPath:VarGet() + "\"+ oNombre:VarGet()+".prj" )

    if !MsgYesNo( "Ya existe el proyecto " + oNombre:VarGet() + Chr(13)+Chr(10) + "¿Desea sobreescribirlo?" )
       oNombre:SetFocus()
       return .F.
    else
       WQout( { "sobreescribir" } )
    endif
 endif





 return .T.






  static FUNCTION TApp_NuevoFile( cType ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

local o


do case
   case cType == "prj"
        ::NuevoProyecto()
   case cType == "bmp"
        __CopyFile( Curdrive()+":\"+Curdir()+"\sample.bmp", Curdrive()+":\"+Curdir()+"\image.bmp")
        ShellExecute( Aplicacion():oWnd:hwnd,"open",Lfn2sfnEx(Curdrive()+":\"+Curdir()+"\image.bmp") )

   case cType == "h"
        o := OpenCode()
        o:AddTextCRLF( "/*                                                                        ")
        o:AddTextCRLF( " * $Id: <fichero>,<version> <año>/<mes>/<dia> <hora>:<minutos>:<segundos> <autor> Exp $")
        o:AddTextCRLF( " */                                                                       ")
        o:AddTextCRLF( "                                                                          ")
        o:AddTextCRLF( "/*                                                                        ")
        o:AddTextCRLF( " * Harbour Project source code:                                           ")
        o:AddTextCRLF( " * Header file for box drawing                                            ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * Copyright 1999 {list of individual authors and e-mail addresses}       ")
        o:AddTextCRLF( " * www - http://www.harbour-project.org                                   ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * This program is free software; you can redistribute it and/or modify   ")
        o:AddTextCRLF( " * it under the terms of the GNU General Public License as published by   ")
        o:AddTextCRLF( " * the Free Software Foundation; either version 2, or (at your option)    ")
        o:AddTextCRLF( " * any later version.                                                     ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * This program is distributed in the hope that it will be useful,        ")
        o:AddTextCRLF( " * but WITHOUT ANY WARRANTY; without even the implied warranty of         ")
        o:AddTextCRLF( " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          ")
        o:AddTextCRLF( " * GNU General Public License for more details.                           ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * You should have received a copy of the GNU General Public License      ")
        o:AddTextCRLF( " * along with this software; see the file COPYING.  If not, write to      ")
        o:AddTextCRLF( " * the Free Software Foundation, Inc., 59 Temple Place, Suite 330,        ")
        o:AddTextCRLF( " * Boston, MA 02111-1307 USA (or visit the web site http://www.gnu.org/). ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * As a special exception, the Harbour Project gives permission for       ")
        o:AddTextCRLF( " * additional uses of the text contained in its release of Harbour.       ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * The exception is that, if you link the Harbour libraries with other    ")
        o:AddTextCRLF( " * files to produce an executable, this does not by itself cause the      ")
        o:AddTextCRLF( " * resulting executable to be covered by the GNU General Public License.  ")
        o:AddTextCRLF( " * Your use of that executable is in no way restricted on account of      ")
        o:AddTextCRLF( " * linking the Harbour library code into it.                              ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * This exception does not however invalidate any other reasons why       ")
        o:AddTextCRLF( " * the executable file might be covered by the GNU General Public License.")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * This exception applies only to the code released by the Harbour        ")
        o:AddTextCRLF( " * Project under the name Harbour.  If you copy code from other           ")
        o:AddTextCRLF( " * Harbour Project or Free Software Foundation releases into a copy of    ")
        o:AddTextCRLF( " * Harbour, as the General Public License permits, the exception does     ")
        o:AddTextCRLF( " * not apply to the code that you add in this way.  To avoid misleading   ")
        o:AddTextCRLF( " * anyone as to the status of such modified files, you must delete        ")
        o:AddTextCRLF( " * this exception notice from them.                                       ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " * If you write modifications of your own for Harbour, it is your choice  ")
        o:AddTextCRLF( " * whether to permit this exception to apply to your modifications.       ")
        o:AddTextCRLF( " * If you do not wish that, delete this exception notice.                 ")
        o:AddTextCRLF( " *                                                                        ")
        o:AddTextCRLF( " */                                                                       ")
   case cType == "prg"
        o := OpenCode()
endcase


return o



  static FUNCTION TApp_Abrir( lCodigo, lRecursos, lImagen, lForm ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


local cFiltro := ""

local cFileName, cExt

If( lCodigo == nil, lCodigo := .T., ) ; If( lRecursos == nil, lRecursos := .T., ); If( lImagen == nil, lImagen := .T., );

if lCodigo



   cFiltro +=    "Código (*.prg) | *.prg; |"                          + "Cabecera (*.ch) | *.ch; |"                          + "C (*.c *.cpp) | *.c;*.cpp; |"                       + "H (*.h) | *.h; |"
endif

if lRecursos
   cFiltro += "Recursos (*.rc *.res *.dll ) | *.rc;*.res;*.dll; |"
endif

if lImagen
   cFiltro += "Imágenes (*.bmp *.gif *.jpg *.ico *.png *.tif ) | *.bmp;*.gif;*.jpg;*.ico;*.png;*.tif; |"
endif

if lForm
   cFiltro += "Formularios (*.ffm) | *.ffm; |"
endif

   cFileName := cGetFile( cFiltro, "Selecciona fichero" )
   if !file( cFileName )
      return .F.
   endif
   cExt := lower(cFileExt( cFileName ))

   do case
      case cExt == "prg" .OR. cExt == "ch" .OR. cExt == "c" .OR. cExt == "cpp" .OR. cExt == "rc" .OR. cExt == "h"
           OpenCode( cFileName )
      case cExt == "bmp" .OR. cExt == "jpg" .OR. cExt == "gif" .OR. cExt == "ico"
           ImageEditor( cFileName )
      case cExt == "dll"
           Recursos( cFileName )
      case cExt == "res"
           RecursosRes( cFileName )
      case cExt == "ffm"

   endcase

return nil


  static FUNCTION TApp_Ftp( ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

local h

Winexec( "easyftp.exe /sv ftp.arrakis.es /us canal_five /pw gomez2 /up" )

return nil







static FUNCTION TApp_Incrustar( nGuia ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

local oWnd, cTitle






local aTitles  := { "Fivewin Programming Guide", "Fivewin Functions guide", "Fivewin command guide", "Fivewin Classes", "FiveODBC Guide", "Editor de diálogos", "demo"}
local hWnd
local aFicheros := {"doc\FWPROG.HLP","doc\FWFUN.HLP","doc\FWCMD.HLP","doc\FWCLASS.HLP","doc\FIVEODBC.HLP","DialogEditor.exe","CxImage.exe"}


cTitle := aTitles[nGuia]

ShellExecute( Aplicacion():oWnd:hwnd,"open",CurDrive() + ":\" + CurDir() + "\" + aFicheros[nGuia] )

syswait( 1 )

hWnd := FindWindow( 0, cTitle )

if hWnd <> 0

   oWnd := TWindow():New(,,,, cTitle,,,, "dialogo", Aplicacion():oWnd,,,,,,, !.F., !.F., !.F., !.F., .F. )

   SetParent( hWnd, oWnd:hWnd )

   SetWindowLong( hWnd, -16, nOr( 33554432, 268435456, 2097152, 1048576 ) )
   SetWindowPos ( hWnd, -1, 0, 0, 0, 0, nOr(0x0001, 0x0002, 0x0020 ) )



   oWnd:Activate(, oWnd:bLClicked, oWnd:bRClicked, oWnd:bMoved, oWnd:bResized := { | nSizeType, nWidth, nHeight | MoveWindow( hWnd, 0, 0, nWidth, nHeight, .T. ) }, oWnd:bPainted, oWnd:bKeyDown, oWnd:bInit := { | Self | oWnd:SetSize( oWnd:nWidth, oWnd:nHeight+1,.T.) },,,,,,,,,,, oWnd:bLButtonUp )

endif


return nil


  static FUNCTION TApp_NuevoProyecto( nProyecto, cName, cLocation ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp

local oPrj

If( nProyecto == nil, nProyecto := 2, ) ;
If( cName == nil, cName := "Proyecto1", ) ;
If( cLocation == nil, cLocation := Curdrive()+":\"+Curdir()+"\", ) ;

if ::oWndPrj == nil

   ::oProyecto := TProyecto():New( cName )
   ::oProyecto:CreaArbol()

endif

::oWndPrj:SetFocus()


return nil


function GetPrgs()

local aPrgs := Aplicacion():oProyecto:oTree:aGetItems( {|x| lower(cFileExt(x:cargo:cFileName)) == "prg" } )
local o


for each o in aPrgs
    WQout( { o:cargo:cFileName } )
next

return nil



  static FUNCTION TApp_SavePrj( cFileName ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


If( cFileName == nil, cFileName := cGetFile( "*.5pj","Guardar proyecto como...", 1, , .T. ), ) ;

if cFileExt( cFileName ) == ""
   cFileName += ".5pj"
endif

::oProyecto:oTree:SaveFile( cFileName )

return nil



  static FUNCTION TApp_LoadPrj( cFileName ) ; local Self AS CLASS TApp := QSelf() AS CLASS TApp


If( cFileName == nil, cFileName := cGetFile( "*.5pj","Seleccione proyecto " ), ) ;

if file( cFileName )
   ::oProyecto:oTree:LoadFile( cFileName )
endif

return nil


_HB_CLASS TWndApp ; function TWndApp ( ... ) ; static s_oClass ; local nScope, oClass, oInstance ; if s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; begin sequence ; nScope := 1 ; ( ( nScope ) ) ; oClass := IIF(.F.,, HBClass():new( "TWndApp" , iif( .T., { @TWindow() }, { @HBObject() } ), @TWndApp() ) ) ;

      _HB_MEMBER { AS LOGICAL lRegistered } ; oClass:AddMultiClsData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRegistered"}, .F. )



      _HB_MEMBER New( nTop, nLeft, nBottom, nRight, cTitle, nStyle, oMenu, oBrush, oIcon, nClrFore, nClrBack, lVScroll, lHScroll, nMenuInfo, cBorder, oWnd, lPixel) AS CLASS TWndApp; oClass:AddMethod( "New", @TWndApp_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam); oClass:AddMethod( "HandleEvent", @TWndApp_HandleEvent(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; oInstance := oClass:Instance() ; if __ObjHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; end ; always ; __clsUnlockDef( @s_oClass, oClass ) ; end ; return oInstance ; end ; return s_oClass:Instance() AS CLASS TWndApp ;




   static FUNCTION TWndApp_New( nTop, nLeft, nBottom, nRight, cTitle, nStyle, oMenu, oBrush, oIcon, nClrFore, nClrBack, lVScroll, lHScroll, nMenuInfo, cBorder, oWnd, lPixel ) ; local Self AS CLASS TWndApp := QSelf() AS CLASS TWndApp






   ::TWindow:New( nTop, nLeft, nBottom, nRight, cTitle, nStyle, oMenu, oBrush, oIcon, nClrFore, nClrBack, lVScroll, lHScroll, nMenuInfo, cBorder, oWnd, lPixel )

return self



   static FUNCTION TWndApp_HandleEvent( nMsg, nWParam, nLParam ) ; local Self AS CLASS TWndApp := QSelf() AS CLASS TWndApp




return ::TWindow:HandleEvent( nMsg, nWParam, nLParam )

function F2 ()
WQout( { "f2" } )
return 0

function F3 ()
WQout( { "f3" } )
return 0

function F4 ()
WQout( { "f4" } )
return 0

function F5 ()
WQout( { "f5" } )
return 0

function F6 ()
WQout( { "f6" } )
return 0

function F7 ()
WQout( { "f7" } )
return 0

function F8 ()
WQout( { "f8" } )
return 0

function F9 ()
WQout( { "f9" } )
return 0

function F10()
WQout( { "f10" } )
return 0

function F11()
Designer()
return 0

function F12()
WQout( { "f12" } )
return 0


Function hLib()

if hFreeImage == nil
   hFreeImage := LoadLibrary( "FreeImage.dll" )
endif
nFreeInstance++

return hFreeImage

Function FreeFreeImage()
--nFreeInstance

if nFreeInstance <= 0
   FreeLibrary( hFreeImage )
   hFreeImage := nil
   nFreeInstance := 0
endif

return nil



function GenPrg()
return ""







#pragma BEGINDUMP


#include <windows.h>
#include <winuser.h>
#include <wingdi.h>
#include "hbapi.h"
#include "hbset.h"
#include "hbapiitm.h"
#include "..\include\uxtheme.h"

HINSTANCE GetInstance( void );

/*
HB_FUNC( EXTCREATEPEN )
{
   LOGBRUSH lb;
   lb.lbStyle = hb_parnl( 1 );
   lb.lbColor = (COLORREF) hb_parnl( 3 );
   lb.lbHatch = hb_parnl( 5 );

   hb_retnl( (LONG) ExtCreatePen( (DWORD) hb_parnl( 1 ),
                                  (DWORD) hb_parnl( 2 ),
                                  &lb                  ,
                                  (DWORD) hb_parnl( 4 ),
                                  NULL ) ) ;
}
*/

HB_FUNC( SETACTIVEWINDOW )
{
         hb_retnl( (LONG) SetActiveWindow( ( HWND ) hb_parnl( 1 )));
}

HB_FUNC( SETFOREGROUNDWINDOW )
{
         hb_retnl( (LONG) SetForegroundWindow( ( HWND ) hb_parnl( 1 )));
}

HB_FUNC( CREATECOMPATIBLEDC )
{
         hb_retnl( (LONG) CreateCompatibleDC( ( HDC ) hb_parnl( 1 )));

}

HB_FUNC( CREATECOMPATIBLEBITMAP )
{
     hb_retnl( (LONG) CreateCompatibleBitmap( (HDC) hb_parnl(1), hb_parni(2), hb_parni(3)));
}


HB_FUNC( CREATEHATCHBRUSH )
{
   hb_retnl( (LONG) CreateHatchBrush( hb_parni( 1 ), hb_parnl( 2 ) ) );
}

HB_FUNC( CREATERECTRGN )
{
    hb_retnl( (LONG) CreateRectRgn( hb_parni( 1 ), hb_parni( 2 ), hb_parni( 3 ), hb_parni( 4 ) ) );
}

HB_FUNC( SELECTCLIPRGN )
{
    hb_retni( SelectClipRgn( ( HDC ) hb_parnl( 1 ), ( HRGN ) hb_parnl( 2 ) ) );
}

HB_FUNC( EXCLUDECLIPRECT )
{
  hb_retni( ExcludeClipRect( ( HDC ) hb_parnl( 1 ),         // handle to DC
                                     hb_parni( 2 ),
                                     hb_parni( 3 ),
                                     hb_parni( 4 ),
                                     hb_parni( 5 )));
}

HB_FUNC( CREATERECTRGNINDIRECT )
{
    RECT rc;

    rc.top = hb_parvni( 1, 1 );
    rc.left = hb_parvni( 1, 2 );
    rc.bottom = hb_parvni( 1, 3 );
    rc.right = hb_parvni( 1, 4 );

    hb_retnl( (LONG) CreateRectRgnIndirect( &rc ) );
}


HB_FUNC( CREATEELLIPTICRGN )
{
    hb_retnl( (LONG) CreateEllipticRgn( hb_parni( 1 ), hb_parni( 2 ), hb_parni( 3 ), hb_parni( 4 ) ) );
}


HB_FUNC( CREATEELLIPTICRGNINDIRECT )
{
    RECT rc;

    rc.top = hb_parvni( 1, 1 );
    rc.left = hb_parvni( 1, 2 );
    rc.bottom = hb_parvni( 1, 3 );
    rc.right = hb_parvni( 1, 4 );

    hb_retnl( (LONG) CreateEllipticRgnIndirect( &rc ) );
}

BOOL Array2Point(PHB_ITEM aPoint, POINT *pt )
{
   if (HB_IS_ARRAY(aPoint) && hb_arrayLen(aPoint) == 2) {
      pt->x = hb_arrayGetNL(aPoint,1);
      pt->y = hb_arrayGetNL(aPoint,2);
      return TRUE ;
   }
   return FALSE;
}

BOOL Array2Rect(PHB_ITEM aRect, RECT *rc )
{
   if (HB_IS_ARRAY(aRect) && hb_arrayLen(aRect) == 4) {
      rc->left   = hb_arrayGetNL(aRect,1);
      rc->top    = hb_arrayGetNL(aRect,2);
      rc->right  = hb_arrayGetNL(aRect,3);
      rc->bottom = hb_arrayGetNL(aRect,4);
      return TRUE ;
   }
   return FALSE;
}


HB_FUNC( CREATEPOLYGONRGN )
{
   POINT * Point ;
   POINT pt ;
   int iCount ;
   int i ;
   PHB_ITEM aParam ;
   PHB_ITEM aSub ;

   if (ISARRAY( 1 ) )
   {
       iCount = (int) hb_parinfa( 1, 0 ) ;
       Point = (POINT *) hb_xgrab( iCount * sizeof (POINT) ) ;
       aParam = hb_param(1,HB_IT_ARRAY);

       for ( i = 0 ; i<iCount ; i++ )
       {
          aSub = hb_itemArrayGet( aParam, i+1 );

          if ( Array2Point(aSub, &pt ))
               *(Point+i) = pt ;
          else {
            hb_retnl(0);
            hb_xfree(Point);
            return ;
          }
       }

       hb_retnl( (LONG) CreatePolygonRgn( Point, iCount, hb_parni( 2 ) ) ) ;
       hb_xfree(Point);

   }
   else
    hb_retnl( 0 );

}


HB_FUNC( CREATEPOLYPOLYGONRGN )
{
   POINT * Point ;
   INT * PolyPoints ;
   int iPolyCount ;
   int iCount ;
   POINT pt ;
   int i ;
   PHB_ITEM aParam ;
   PHB_ITEM aSub ;

   if (ISARRAY( 1 ) && ISARRAY( 2 ) )
   {
       iPolyCount = hb_parinfa(2,0) ;
       PolyPoints = ( INT *) hb_xgrab( iPolyCount * sizeof( INT ) ) ;

       for ( i=0 ; i < iPolyCount ; i++ )
       {
          *(PolyPoints+i) = hb_parvni( 2,i+1) ;
       }

       iCount = hb_parinfa( 1, 0 ) ;
       Point = (POINT *) hb_xgrab( iCount * sizeof (POINT) ) ;
       aParam = hb_param(1,HB_IT_ARRAY);

       for ( i = 0 ; i<iCount ; i++ )
       {
          aSub = hb_itemArrayGet( aParam, i+1 );

          if ( Array2Point(aSub, &pt ))
               *(Point+i) = pt ;
          else {
            hb_retnl(0);
            hb_xfree(PolyPoints);
            hb_xfree(Point);
            return ;
          }
       }

       hb_retnl( (LONG) CreatePolyPolygonRgn( Point, PolyPoints, iPolyCount, hb_parni( 3 ) ) ) ;
       hb_xfree(PolyPoints);
       hb_xfree(Point);

   }
   else
    hb_retnl( 0 );

}

HB_FUNC( CREATEROUNDRECTRGN )
{
   hb_retnl( (LONG) CreateRoundRectRgn( hb_parni( 1 ),
                                        hb_parni( 2 ),
                                        hb_parni( 3 ),
                                        hb_parni( 4 ),
                                        hb_parni( 5 ),
                                        hb_parni( 6 ) ) ) ;
}

HB_FUNC( SETRECTRGN )
{
   hb_retl( SetRectRgn( (HRGN) hb_parnl( 1 ),
                        hb_parni( 2 )       ,
                        hb_parni( 3 )       ,
                        hb_parni( 4 )       ,
                        hb_parni( 5 )      ) ) ;
}

HB_FUNC( EQUALRGN )
{
   hb_retl( EqualRgn( (HRGN) hb_parnl( 1 ), (HRGN) hb_parnl( 2 ) ) ) ;
}


HB_FUNC( COMBINERGN )
{
   HRGN hrgnDest;
   HRGN hrgnSrc1 = ( HRGN ) hb_parnl( 1 );
   HRGN hrgnSrc2 = ( HRGN ) hb_parnl( 2 );
   int fnCombineMode = hb_parni( 3 );
   hb_retni( CombineRgn( hrgnDest, hrgnSrc1, hrgnSrc2, fnCombineMode ));

}

HB_FUNC( PATHTOREGION )
{
   hb_retnl( (LONG) PathToRegion( (HDC) hb_parnl( 1 ) ) ) ;
}

HB_FUNC( OFFSETRGN )
{
   hb_retni( OffsetRgn( (HRGN) hb_parnl( 1 ), hb_parni( 2 ), hb_parni( 3 ) ) ) ;
}


HB_FUNC( GETRGNBOX )
{
   RECT rc;
   hb_retni( GetRgnBox( (HRGN) hb_parnl( 1 ), &rc ) ) ;
   hb_storvnl( rc.left  , 2 ,2 );
   hb_storvnl( rc.top   , 2, 1 );
   hb_storvnl( rc.right , 2 ,4 );
   hb_storvnl( rc.bottom, 2, 3 );
}


HB_FUNC( PTINREGION )
{
   hb_retl( PtInRegion( (HRGN) hb_parnl( 1 ), hb_parni( 2 ), hb_parni( 3 ) ) ) ;
}

HB_FUNC( RECTINREGION )
{
    RECT rc;

   if (ISARRAY( 2 ) && Array2Rect( hb_param( 2, HB_IT_ARRAY ), &rc ) )
      hb_retl( RectInRegion( (HRGN) hb_parnl( 1 ), &rc ) ) ;
}

HB_FUNC( DRAWFOCUSRECT )  //RECT

{
   RECT rct ;
   HDC  hDC = ( HDC ) hb_parni( 1 );

   rct.top    = hb_parni( 2 );
   rct.left   = hb_parni( 3 );
   rct.bottom = hb_parni( 4 );
   rct.right  = hb_parni( 5 );

   DrawFocusRect( hDC, &rct );

}

HB_FUNC( FILLSOLIDRECT )
{
    RECT rct;
    COLORREF nColor;
    HPEN hPen, hOldPen;
    HDC hDC = ( HDC ) hb_parnl( 1 );
    rct.top    = hb_parvni( 2, 1 );
    rct.left   = hb_parvni( 2, 2 );
    rct.bottom = hb_parvni( 2, 3 );
    rct.right  = hb_parvni( 2, 4 );

    nColor = SetBkColor( hDC, hb_parvnl( 3 ) );
    ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rct, NULL, 0, NULL);
    SetBkColor( hDC, nColor );

    if( hb_pcount()  > 3 )
    {
       hPen = CreatePen( PS_SOLID, 1,(COLORREF)hb_parnl( 4 ));
       hOldPen = (HPEN) SelectObject( hDC, hPen );
       MoveToEx( hDC, rct.left, rct.top, NULL );
       LineTo( hDC, rct.right-1, rct.top );
       LineTo( hDC, rct.right-1, rct.bottom-1 );
       LineTo( hDC, rct.left, rct.bottom-1 );
       LineTo( hDC, rct.left, rct.top );
       SelectObject( hDC, hOldPen );
       DeleteObject( hPen );
    }

}

HB_FUNC( PTINRECT )
   {
      POINT pt;
      RECT  rct;

      pt.y = hb_parnl( 1 );
      pt.x = hb_parnl( 2 );

      rct.top    = hb_parvni( 3, 1 );
      rct.left   = hb_parvni( 3, 2 );
      rct.bottom = hb_parvni( 3, 3 );
      rct.right  = hb_parvni( 3, 4 );

      hb_retl( PtInRect( &rct, pt ) );
   }

   HB_FUNC( INTERSECTRECT )
   {

      RECT rc, rc01, rc02;
      RECT rc0, rc1;

      rc01.top = hb_parvni( 1, 1 );
      rc01.left = hb_parvni( 1, 2 );
      rc01.bottom = hb_parvni( 1, 3 );
      rc01.right = hb_parvni( 1, 4 );

      rc02.top = hb_parvni( 2, 1 );
      rc02.left = hb_parvni( 2, 2 );
      rc02.bottom = hb_parvni( 2, 3 );
      rc02.right = hb_parvni( 2, 4 );

      rc0 = rc01;
      rc1 = rc02;

      hb_retl( IntersectRect( &rc, &rc0, &rc1 ) );

   }

   HB_FUNC( SETROP2 )  // (hdc, fnDrawMode)
   {
      hb_retni( ( LONG ) SetROP2( ( HDC ) hb_parni( 1 ), hb_parnl( 2 ) ));
   }

   HB_FUNC( UNIONRECT )
   {

      RECT rc, rc0, rc1;


      rc0.top    = hb_parvni( 1, 1 );
      rc0.left   = hb_parvni( 1, 2 );
      rc0.bottom = hb_parvni( 1, 3 );
      rc0.right  = hb_parvni( 1, 4 );

      rc1.top    = hb_parvni( 2, 1 );
      rc1.left   = hb_parvni( 2, 2 );
      rc1.bottom = hb_parvni( 2, 3 );
      rc1.right  = hb_parvni( 2, 4 );

      UnionRect( &rc, &rc0, &rc1 );
      hb_reta(4);

      hb_storvni( rc.top    , -1, 1 );
      hb_storvni( rc.left   , -1, 2 );
      hb_storvni( rc.bottom , -1, 3 );
      hb_storvni( rc.right  , -1, 4 );

   }

   HB_FUNC( DRAWEDGE )
   {
      HDC hDC     = (HDC) hb_parnl( 1 );
      RECT rc;
      HBRUSH hOldBrush;
      rc.top    = hb_parvni( 2, 1);
      rc.left   = hb_parvni( 2, 2);
      rc.bottom = hb_parvni( 2, 3);
      rc.right  = hb_parvni( 2, 4);

      hb_retl( DrawEdge( hDC, &rc, hb_parnl( 3 ), hb_parnl( 4 ) ) );
   }

   HB_FUNC( FONTCAPTION )
   {
        BOOL bTool = hb_parl(1);
        HFONT hFont;
        NONCLIENTMETRICS info;
        //BOOL bRet;
        info.cbSize = sizeof(info);
        SystemParametersInfo( SPI_GETNONCLIENTMETRICS, sizeof(info), &info, 0 );
        if( bTool )
        {
            hFont = CreateFontIndirect( &info.lfSmCaptionFont );
        }
        else
        {
            hFont = CreateFontIndirect( &info.lfCaptionFont );
        }
        hb_retnl( (LONG) hFont );
   }
/*
typedef struct tagNONCLIENTMETRICS {  UINT cbSize;
  int iBorderWidth;
  int iScrollWidth;
  int iScrollHeight;
  int iCaptionWidth;
  int iCaptionHeight;
  LOGFONT lfCaptionFont;
  int iSmCaptionWidth;
  int iSmCaptionHeight;
  LOGFONT lfSmCaptionFont;
  int iMenuWidth ;
  int iMenuHeight;
  LOGFONT lfMenuFont;
  LOGFONT lfStatusFont;
  LOGFONT lfMessageFont;
}
*/
   HB_FUNC( METRICSCAPTION )
   {
      HFONT hFont;
        NONCLIENTMETRICS info;
        //BOOL bRet;
        info.cbSize = sizeof(info);
        SystemParametersInfo( SPI_GETNONCLIENTMETRICS, sizeof(info), &info, 0 );
        hb_reta( 7 );
        hb_storvni( info.iCaptionWidth,    -1, 1 );
        hb_storvni( info.iCaptionHeight,   -1, 2 );
        hb_storvni( info.iSmCaptionWidth,  -1, 3 );
        hb_storvni( info.iSmCaptionHeight, -1, 4 );
        hb_storvni( info.iBorderWidth,     -1, 5 );
        hb_storvni( info.iMenuWidth ,      -1, 6 );
        hb_storvni( info.iMenuHeight,      -1, 7 );
   }

   HB_FUNC( DRAWCAPTION )
   {
      RECT rc;
      rc.top    = hb_parvni( 3, 1);
      rc.left   = hb_parvni( 3, 2);
      rc.bottom = hb_parvni( 3, 3);
      rc.right  = hb_parvni( 3, 4);

       hb_retl( DrawCaption( ( HWND )hb_parnl( 1 ), ( HDC ) hb_parnl( 2 ), &rc, hb_parni(4)));
   }

   HB_FUNC( BOX )
   {
      HDC hDC = (HDC) hb_parnl( 1 );
      HPEN hPen;
      HPEN hOldPen;
      RECT rc;

      if( hb_pcount() > 3 )
      {
         hPen = CreatePen( hb_parni(4),1, (COLORREF)hb_parnl( 3 ));
      }
      else
      {
         hPen = CreatePen( PS_SOLID,1, (COLORREF)hb_parnl( 3 ));
      }
      rc.top    = hb_parvni( 2, 1);
      rc.left   = hb_parvni( 2, 2);
      rc.bottom = hb_parvni( 2, 3);
      rc.right  = hb_parvni( 2, 4);
      hOldPen = (HPEN) SelectObject( hDC, hPen );
      MoveToEx( hDC, rc.left, rc.top, NULL );
      LineTo( hDC, rc.right, rc.top );
      LineTo( hDC, rc.right, rc.bottom );
      LineTo( hDC, rc.left, rc.bottom );
      LineTo( hDC, rc.left, rc.top );
      SelectObject( hDC, hOldPen );
      DeleteObject( hPen );
   }

   HB_FUNC( LINE )
   {
      HDC hDC = (HDC) hb_parnl( 1 );
      HPEN hPen = CreatePen( PS_SOLID,1, (COLORREF)hb_parnl( 6 ));
      HPEN hOldPen;
      hOldPen = (HPEN) SelectObject( hDC, hPen );
      MoveToEx( hDC, hb_parni( 3 ), hb_parni( 2 ), NULL );
      LineTo( hDC, hb_parni( 5 ), hb_parni( 4 ) );
      SelectObject( hDC, hOldPen );
      DeleteObject( hPen );
   }


   HB_FUNC( ISWINDOWVISIBLE )
   {
      hb_retl( IsWindowVisible( (HWND) hb_parnl(1) ) );
   }

   //////////////////////////////////////////////////////////////////////////   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////

   LPWSTR AnsiToWide( LPSTR cAnsi )
   {
      WORD wLen;
      LPWSTR cString;

      wLen  = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, cAnsi, -1, 0, 0 );

      cString = (LPWSTR) hb_xgrab( wLen * 2 );
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, cAnsi, -1, cString, wLen );

      return ( cString );
   }

   //--------------------------------------------------------------------------

   LPSTR WideToAnsi( LPWSTR cWide )
   {
      WORD wLen;
      LPSTR cString;

      wLen = WideCharToMultiByte( CP_ACP, 0, cWide, -1, cString, 0, NULL, NULL );

      cString = (LPSTR) hb_xgrab( wLen );
      WideCharToMultiByte( CP_ACP, 0, cWide, -1, cString, wLen, NULL, NULL );

      return ( cString );
   }


   HB_FUNC ( ANSITOWIDE )  // ( cAnsiStr ) -> cWideStr
   {
      WORD wLen;
      LPSTR cOut;

      wLen = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, hb_parc( 1 ), -1, 0, 0 );
      cOut = ( char * ) hb_xgrab( wLen * 2 );
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, hb_parc( 1 ), -1, ( LPWSTR ) cOut, wLen );

      hb_retclen( cOut, wLen * 2 - 1 );
      hb_xfree( cOut );
   }

   //--------------------------------------------------------------------------

   HB_FUNC ( WIDETOANSI )  // ( cWideStr, nLen ) -> cAnsiStr
   {
      WORD wLen;
      LPWSTR cWideStr;
      LPSTR cOut;

      cWideStr = ( LPWSTR ) hb_parc( 1 );
      wLen = WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK, cWideStr, -1, cOut, 0, NULL, NULL );
      cOut = ( char * ) hb_xgrab( wLen );
      WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK, cWideStr, -1, cOut, wLen, NULL, NULL );

      hb_retc( cOut );
      hb_xfree( cOut );
   }

   //
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   // ~~~~~~~ MANEJO DE TEMAS ~~~~~~
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   //
   // C5_ISTHEMEACTIVE
   // C5_OPENTHEMEDATA
   // C5_CLOSETHEMEDATA
   // C5_GETCURRENTTHEMENAME
   // C5_DRAWTHEMEBACKGROUND

   HB_FUNC( C5_ISAPPTHEMED )
   {
      typedef BOOL (CALLBACK* LPFNDLLFUNC2)();
      HINSTANCE hLib;
      LPFNDLLFUNC2 IsAppThemed;
      BOOL bIsAppThemed = FALSE;

      hLib = LoadLibrary( "uxtheme.dll" );
      if( hLib )
      {
          (LPFNDLLFUNC2)IsAppThemed = ((LPFNDLLFUNC2) GetProcAddress( hLib, "IsAppThemed" ));
          bIsAppThemed = (BOOL) IsAppThemed();
          FreeLibrary( hLib );
      }
      hb_retl(bIsAppThemed);
   }


   HB_FUNC( C5_ISTHEMEACTIVE ) // --> BOOL
   {
      typedef BOOL (CALLBACK* LPFNDLLFUNC2)();
      HINSTANCE hLib;
      LPFNDLLFUNC2 IsThemeActive;
      BOOL bIsActive = FALSE;

      hLib = LoadLibrary( "uxtheme.dll" );
      if( hLib )
      {
          IsThemeActive = ((LPFNDLLFUNC2) GetProcAddress( hLib, "IsThemeActive" ));
          bIsActive = (BOOL) IsThemeActive();
          FreeLibrary( hLib );
      }
      hb_retl(bIsActive);
   }

   HB_FUNC( C5_OPENTHEMEDATA ) //( ::hWnd, cTheme )
   {
     typedef HTHEME   ( FAR PASCAL  *LPOPENTHEMEDATA )( HWND hwnd, LPCSTR pszClassList );
     LPWSTR cTheme = AnsiToWide( hb_parc( 2 ) );
     HINSTANCE hLib;
     LPOPENTHEMEDATA OpenThemeData;

     hLib = LoadLibrary( "uxtheme.dll" );

     if ( hLib )
     {
         OpenThemeData = (LPOPENTHEMEDATA) GetProcAddress( hLib, "OpenThemeData" );
         hb_retnl( ( LONG ) OpenThemeData( ( HWND ) hb_parnl( 1 ) , ( LPCSTR ) cTheme ) ); //
         FreeLibrary( hLib );
     }
     hb_xfree( cTheme );
   }

   HB_FUNC( C5_CLOSETHEMEDATA )
   {
      typedef HRESULT  ( FAR PASCAL  *LPCLOSETHEMEDATA )     ( HTHEME hTheme );
      HINSTANCE hLib ;
      LPCLOSETHEMEDATA CloseThemeData;
      hLib = LoadLibrary( "uxtheme.dll" );
      if ( hLib )
      {
          CloseThemeData = (LPCLOSETHEMEDATA) GetProcAddress( hLib, "CloseThemeData" );
          hb_retni( CloseThemeData( (HTHEME) hb_parnl( 1 ) ) );
          FreeLibrary( hLib );
      }
   }


   HB_FUNC( C5_GETCURRENTTHEMENAME )
   {
     typedef HRESULT  ( FAR PASCAL  *LPGETCURRENTTHEMENAME) ( LPWSTR pszThemeFileName, int cchMaxNameChars, LPWSTR pszColorBuff, int cchMaxColorChars, LPWSTR pszSizeBuff, int cchMaxSizeChars);
     WCHAR pszThemeFileName[MAX_PATH];
     HINSTANCE hLib;
     LPGETCURRENTTHEMENAME GetCurrentThemeName;
     LPSTR cOut;

     hLib = LoadLibrary( "uxtheme.dll" );
     if ( hLib )
     {
         GetCurrentThemeName = (LPGETCURRENTTHEMENAME) GetProcAddress( hLib, "GetCurrentThemeName" );
         GetCurrentThemeName( (LPWSTR) pszThemeFileName, MAX_PATH, NULL, 0, NULL, 0 );
         cOut = WideToAnsi( pszThemeFileName );
         hb_retc( cOut );
         hb_xfree( cOut );
         FreeLibrary( hLib );
     }
   }

   HB_FUNC( C5_DRAWTHEMEBACKGROUND ) //( ::hTheme, hDC, nPartID, nStateID, pRect, pClipRect )
   {
     typedef HRESULT  ( FAR PASCAL  *LPDRAWTHEMEBACKGROUND )( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
     HINSTANCE hLib;
     LPDRAWTHEMEBACKGROUND DrawThemeBackground;
     int iRet;
     RECT pRect;

     pRect.top    = hb_parvnl( 5, 1 );
     pRect.left   = hb_parvnl( 5, 2 );
     pRect.bottom = hb_parvnl( 5, 3 );
     pRect.right  = hb_parvnl( 5, 4 );

     hLib = LoadLibrary( "uxtheme.dll" );
     if ( hLib )
     {
         DrawThemeBackground = (LPDRAWTHEMEBACKGROUND) GetProcAddress( hLib, "DrawThemeBackground" );
         iRet = DrawThemeBackground( ( HTHEME ) hb_parnl( 1 ),
                                          (HDC) hb_parnl( 2 ),
                                                hb_parni( 3 ),
                                                hb_parni( 4 ),
                                                &pRect,
                                                NULL );
         FreeLibrary( hLib );
     }
     hb_retni( iRet );
   }

/*HRESULT DrawThemeIcon(          HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pRect,
    HIMAGELIST himl,
    int iImageIndex
);*/

   HB_FUNC( C5_DRAWTHEMEICON ) //( ::hTheme, hDC, nPartID, nStateID, pRect, himl, index )
   {
     typedef HRESULT  ( FAR PASCAL  *LPDRAWTHEMEICON )( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, HIMAGELIST il, int index );
     HINSTANCE hLib;
     LPDRAWTHEMEICON DrawThemeIcon;
     int iRet;
     RECT pRect;

     pRect.top    = hb_parvnl( 5, 1 );
     pRect.left   = hb_parvnl( 5, 2 );
     pRect.bottom = hb_parvnl( 5, 3 );
     pRect.right  = hb_parvnl( 5, 4 );

     hLib = LoadLibrary( "uxtheme.dll" );
     if ( hLib )
     {
         DrawThemeIcon = (LPDRAWTHEMEICON) GetProcAddress( hLib, "DrawThemeIcon" );
         iRet = DrawThemeIcon( ( HTHEME )     hb_parnl( 1 ),
                               ( HDC )        hb_parnl( 2 ),
                                              hb_parni( 3 ),
                                              hb_parni( 4 ),
                                              &pRect,
                               ( HIMAGELIST ) hb_parnl( 6 ),
                                              hb_parni( 7 ));
         FreeLibrary( hLib );
     }
     hb_retni( iRet );
   }

/*HRESULT DrawThemeEdge(          HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pDestRect,
    UINT uEdge,
    UINT uFlags,
    RECT *pContentRect
);*/
HB_FUNC( C5_DRAWTHEMEEDGE )
{
     typedef HRESULT  ( FAR PASCAL  *LPDRAWTHEMEEDGE )( HTHEME hTheme,
                                                        HDC hdc,
                                                        int iPartId,
                                                        int iStateId,
                                                        const RECT *pDestRect,
                                                        UINT uEdge,
                                                        UINT uFlags,
                                                        RECT *pContentRect );
     HINSTANCE hLib;
     LPDRAWTHEMEEDGE DrawThemeEdge;
     int iRet;
     RECT pRect;
     RECT pContentRect;

     pRect.top    = hb_parvnl( 5, 1 );
     pRect.left   = hb_parvnl( 5, 2 );
     pRect.bottom = hb_parvnl( 5, 3 );
     pRect.right  = hb_parvnl( 5, 4 );

     pContentRect.top    = hb_parvnl( 5, 1 );
     pContentRect.left   = hb_parvnl( 5, 2 );
     pContentRect.bottom = hb_parvnl( 5, 3 );
     pContentRect.right  = hb_parvnl( 5, 4 );

     hLib = LoadLibrary( "uxtheme.dll" );
     if ( hLib )
     {
         DrawThemeEdge = (LPDRAWTHEMEEDGE) GetProcAddress( hLib, "DrawThemeEdge" );
         iRet = DrawThemeEdge( ( HTHEME )     hb_parnl( 1 ),
                               ( HDC )        hb_parnl( 2 ),
                                              hb_parni( 3 ),
                                              hb_parni( 4 ),
                                              &pRect,
                                              hb_parni( 6 ),
                                              hb_parni( 7 ),
                                              &pContentRect );
         FreeLibrary( hLib );
     }
     hb_retni( iRet );
}


/*HRESULT DrawThemeText(          HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    LPCWSTR pszText,
    int iCharCount,
    DWORD dwTextFlags,
    DWORD dwTextFlags2,
    const RECT *pRect
);*/

   HB_FUNC( C5_DRAWTHEMETEXT ) //( ::hWnd, cTheme )
   {
     typedef HRESULT ( FAR PASCAL  *LPDRAWTHEMETEXT )( HTHEME hTheme,
                                                       HDC hdc,
                                                       int iPartId,
                                                       int iStateId,
                                                       LPCWSTR pszText,
                                                       int iCharCount,
                                                       DWORD dwTextFlags,
                                                       DWORD dwTextFlags2,
                                                       RECT *rc );

     LPCWSTR pszText = AnsiToWide( hb_parc( 5 ) );
     HINSTANCE hLib;
     LPDRAWTHEMETEXT DrawThemeText;
     RECT rc;

     rc.top     = hb_parvnl( 8, 1 );
     rc.left    = hb_parvnl( 8, 2 );
     rc.bottom  = hb_parvnl( 8, 3 );
     rc.right   = hb_parvnl( 8, 4 );


     hLib = LoadLibrary( "uxtheme.dll" );

     if ( hLib )
     {
         DrawThemeText = (LPDRAWTHEMETEXT) GetProcAddress( hLib, "DrawThemeText" );
         hb_retnl( ( LONG ) DrawThemeText( ( HTHEME ) hb_parnl( 1 ),
                            ( HDC )    hb_parnl( 2 ),
                            hb_parni( 3 ),
                            hb_parni( 4 ),
                 (LPCWSTR)  pszText,
                            -1,
                            hb_parnl( 6 ),
                            hb_parnl( 7 ),
                            &rc ) );          //
         FreeLibrary( hLib );
     }
     hb_xfree( pszText );
   }

/*HRESULT GetThemeBackgroundContentRect(          HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    const RECT *pBoundingRect,
    RECT *pContentRect
);
*/


HB_FUNC( GETTHEMEFONT )   //(::hTheme, hDC, nPartID, nStateID, nPropID, pFont)
{

  LOGFONT plf;
  HFONT hFont;
  typedef HRESULT ( FAR PASCAL  *LPGETTHEMEFONT )( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, int iPropId, LOGFONT *pFont);
  HINSTANCE hLib;
  LPGETTHEMEFONT GetThemeFont;

  ZeroMemory( &plf, sizeof(plf) );

  hLib = LoadLibrary( "uxtheme.dll" );

  if ( hLib )
  {
      GetThemeFont = (LPGETTHEMEFONT) GetProcAddress( hLib, "GetThemeFont" );
      hb_retnl( ( LONG ) GetThemeFont((HTHEME) hb_parnl( 1 ),
                       ( HDC ) hb_parnl( 2 ),
                       hb_parni( 3 ),
                       hb_parni( 4 ),
                       hb_parni( 5 ),
                       &plf ) );          //
      hFont = CreateFontIndirect( &plf );
      hb_retnl( (long) hFont );
      FreeLibrary( hLib );
      return;
  }
  hb_ret();
}


/*HRESULT GetThemeSysFont(          HTHEME hTheme,
    int iFontID,
    LOGFONT *plf
);*/

HB_FUNC( GETTHEMESYSFONT )   //(::hTheme, hDC, nPartID, nStateID, nPropID, pFont)
{
  LOGFONT plf;
  HFONT hFont;
  typedef HRESULT ( FAR PASCAL  *LPGETTHEMESYSFONT )( HTHEME hTheme, int iFontID,LOGFONT *pFont);
  HINSTANCE hLib;
  LPGETTHEMESYSFONT GetThemeSysFont;

  ZeroMemory( &plf, sizeof(plf) );

  hLib = LoadLibrary( "uxtheme.dll" );

  if ( hLib )
  {
      GetThemeSysFont = (LPGETTHEMESYSFONT) GetProcAddress( hLib, "GetThemeSysFont" );
      GetThemeSysFont((HTHEME) hb_parnl( 1 ),
                               hb_parni( 2 ),
                               &plf );          //
      hFont = CreateFontIndirect( &plf );
      hb_retnl( (long) hFont );
      FreeLibrary( hLib );
      return;
  }
  hb_ret();

}

HB_FUNC(GETTHEMECOLOR)   //(::hTheme, nPartID, nStateID, nPropID, pColor)
{
  COLORREF color;
  typedef HRESULT ( FAR PASCAL  *LPGETTHEMECOLOR )( HTHEME hTheme, int iPartId, int iStateId, int nPropID, COLORREF *color);
  HINSTANCE hLib;
  LPGETTHEMECOLOR GetThemeColor;
  int iPropId = 204;
  if( hb_pcount() > 3 )
  {
     iPropId = hb_parni( 4 );
  }

  hLib = LoadLibrary( "uxtheme.dll" );

  if ( hLib )
  {
      GetThemeColor = (LPGETTHEMECOLOR) GetProcAddress( hLib, "GetThemeColor" );
      hb_retnl( ( LONG ) GetThemeColor((HTHEME) hb_parnl( 1 ),
                                               hb_parni( 2 ),
                                               hb_parni( 3 ),
                                               iPropId,
                                               &color ) );          //
      FreeLibrary( hLib );
      hb_retnl( (long) color );
      return;
  }
  hb_ret();
}

/*HRESULT GetThemeMetric(          HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    int iPropId,
    int *piVal
);
*/
HB_FUNC( GETTHEMEMETRIC )
{
  typedef HRESULT ( FAR PASCAL  *LPGETTHEMEMETRIC )( HTHEME hTheme, HDC hDC, int iPartId, int iStateId, int iPropId, int *piVal );
  HINSTANCE hLib;
  LPGETTHEMEMETRIC GetThemeMetric;
  int iVal = 0;

  hLib = LoadLibrary( "uxtheme.dll" );

  if ( hLib )
  {
      GetThemeMetric = (LPGETTHEMEMETRIC) GetProcAddress( hLib, "GetThemeMetric" );
      GetThemeMetric((HTHEME) hb_parnl( 1 ), ( HDC ) hb_parnl( 2 ),
                                                     hb_parni( 3 ),
                                                     hb_parni( 4 ),
                                                     hb_parni( 5 ),
                                                     &iVal ) ;
      FreeLibrary( hLib );
      hb_retni( iVal );
      return;
  }
  hb_retni( iVal );
}
/*
HRESULT GetThemePartSize(          HTHEME hTheme,
    HDC hdc,
    int iPartId,
    int iStateId,
    RECT *prc,
    THEMESIZE eSize,
    SIZE *psz
);*/

HB_FUNC( GETTHEMEPARTSIZE )
{
  typedef HRESULT ( FAR PASCAL  *LPGETTHEMEPARTSIZE )(HTHEME hTheme, HDC hdc, int iPartId,
                                                         int iStateId, RECT * pRect, enum THEMESIZE eSize, SIZE *psz);
  HINSTANCE hLib;
  LPGETTHEMEPARTSIZE GetThemePartSize;
  SIZE sz;
  sz.cx = 0;
  sz.cy = 0;

  hLib = LoadLibrary( "uxtheme.dll" );

  if ( hLib )
  {
      GetThemePartSize = (LPGETTHEMEPARTSIZE) GetProcAddress( hLib, "GetThemePartSize" );
      GetThemePartSize((HTHEME) hb_parnl( 1 ), ( HDC ) hb_parnl( 2 ),
                                                       hb_parni( 3 ),
                                                       hb_parni( 4 ),
                                                (RECT*) NULL,
                                                       TS_TRUE,
                                                       &sz ) ;
        FreeLibrary( hLib );
      hb_retni( sz.cy );
      return;
  }
  hb_retni( sz.cy );
}

HB_FUNC( GETTHEMESYSCOLOR )
{

  COLORREF color;
  typedef COLORREF ( FAR PASCAL  *LPGETTHEMESYSCOLOR )( HTHEME hTheme, int iColorID );
  HINSTANCE hLib;
  LPGETTHEMESYSCOLOR GetThemeSysColor;

  hLib = LoadLibrary( "uxtheme.dll" );

  if ( hLib )
  {
      GetThemeSysColor = (LPGETTHEMESYSCOLOR) GetProcAddress( hLib, "GetThemeSysColor" );
      GetThemeSysColor((HTHEME) hb_parnl( 1 ), hb_parni( 2 )) ;          //
      FreeLibrary( hLib );
      hb_retnl( (long) color );
      return;
  }
  hb_ret();

}

/*HRESULT GetThemeBackgroundContentRect( HTHEME hTheme,
                                         HDC hdc,
                                         int iPartId,
                                         int iStateId,
                                         const RECT *pBoundingRect,
                                         RECT *pContentRect
);
*/
HB_FUNC( GETTHEMEBACKGROUNDCONTENTRECT )
{
  typedef HRESULT ( FAR PASCAL  *LPGETTHEMEBACKGROUNDCONTENTRECT )(HTHEME hTheme,
                                         HDC hdc,
                                         int iPartId,
                                         int iStateId,
                                         const RECT *pBoundingRect,
                                         RECT *pContentRect );
  HINSTANCE hLib;
  LPGETTHEMEBACKGROUNDCONTENTRECT GetThemeBackgroundContentRect;
  RECT rcout;
  RECT rc;

  rc.top     = hb_parvnl( 5, 1 );
  rc.left    = hb_parvnl( 5, 2 );
  rc.bottom  = hb_parvnl( 5, 3 );
  rc.right   = hb_parvnl( 5, 4 );

  rcout.top     = hb_parvnl( 5, 1 );
  rcout.left    = hb_parvnl( 5, 2 );
  rcout.bottom  = hb_parvnl( 5, 3 );
  rcout.right   = hb_parvnl( 5, 4 );



  hLib = LoadLibrary( "uxtheme.dll" );

  if ( hLib )
  {
      GetThemeBackgroundContentRect = (LPGETTHEMEBACKGROUNDCONTENTRECT) GetProcAddress( hLib, "GetThemeBackgroundContentRect" );
      GetThemeBackgroundContentRect( (HTHEME) hb_parnl( 1 ),
                                     (HDC)    hb_parnl( 2 ),
                                              hb_parni( 3 ),
                                              hb_parni( 4 ),
                                              &rc          ,
                                              &rcout );          //
      FreeLibrary( hLib );

  }
  hb_reta(4);

  hb_storvni( rcout.top    , -1, 1 );
  hb_storvni( rcout.left   , -1, 2 );
  hb_storvni( rcout.bottom , -1, 3 );
  hb_storvni( rcout.right  , -1, 4 );
}

HB_FUNC( STRETCHBLT )
{
   hb_retl( StretchBlt( (HDC) hb_parnl( 1 )   ,
                        hb_parni( 2 )         ,
                        hb_parni( 3 )         ,
                        hb_parni( 4 )         ,
                        hb_parni( 5 )         ,
                        (HDC) hb_parnl( 6 )   ,
                        hb_parni( 7 )         ,
                        hb_parni( 8 )         ,
                        hb_parni( 9 )         ,
                        hb_parni( 10 )        ,
                        (DWORD) hb_parnl( 11 )
                        ) ) ;
}


HB_FUNC( REGISTERWINDOWMESSAGE )
{
     hb_retni( RegisterWindowMessage( ( LPCTSTR ) hb_parc(1)));
}

HB_FUNC( SETBRUSHORGEX )
{
   SetBrushOrgEx( (HDC) hb_parnl( 1 ), hb_parni( 2 ), hb_parni( 3 ), NULL );
   hb_ret();
}

/*BOOL SetWindowOrgEx(
  HDC hdc,        // handle to device context
  int X,          // new x-coordinate of window origin
  int Y,          // new y-coordinate of window origin
  LPPOINT lpPoint // original window origin
);*/
HB_FUNC( SETWINDOWORGEX )
{
   POINT pt;
   pt.x = 0;
   pt.y = 0;
   SetWindowOrgEx( (HDC) hb_parnl( 1 ), hb_parni( 2 ), hb_parni( 3 ), &pt );
   hb_reta( 2 );
   hb_storvni( pt.y, -1, 1 );
   hb_storvni( pt.x, -1, 2 );

}

HB_FUNC( DSGNBORDE )
{

   HDC dc = (HDC) hb_parnl( 1 );
   HBITMAP bmp  = LoadBitmap( GetInstance(), "brush" );
   HBITMAP bmp2 = LoadBitmap( GetInstance(), "brush" );
   int nXMiddle;
        int nYMiddle;
   COLORREF color;
   HBRUSH br, br2, hOldBrush;
   POINT pt;
   RECT rc, rcPaint;

   rc.top    = hb_parvni( 2, 1 );
   rc.left   = hb_parvni( 2, 2 );
   rc.bottom = hb_parvni( 2, 3 );
   rc.right  = hb_parvni( 2, 4 );

        br2 = CreatePatternBrush( bmp2 );
        br = CreatePatternBrush( bmp );

        nXMiddle = (rc.right-rc.left) / 2;
        nYMiddle = (rc.bottom-rc.top) / 2;

   hOldBrush = (HBRUSH) SelectObject( dc, br );
   color = SetBkColor( dc, RGB( 255,0,0) );

   SetBrushOrgEx( dc, rc.left, rc.top, NULL );
        SetRect( &rcPaint, rc.left, rc.top, rc.right, rc.top + 7 );
        PatBlt( dc, rcPaint.left, rcPaint.top, rcPaint.right-rcPaint.left, rcPaint.bottom-rcPaint.top, PATCOPY );
        //FillRect( dc, &rcPaint, br );


   SetBrushOrgEx( dc, rc.left, rc.top, NULL );
        SetRect( &rcPaint, rc.left, rc.top, rc.left + 7, rc.bottom );
        PatBlt( dc, rcPaint.left, rcPaint.top, rcPaint.right-rcPaint.left, rcPaint.bottom-rcPaint.top, PATCOPY );
        //FillRect( dc, &rcPaint, br );

   SetBrushOrgEx( dc, rc.left, rc.bottom - 7, NULL );
        SetRect( &rcPaint, rc.left, rc.bottom - 7, rc.right, rc.bottom );
        PatBlt( dc, rcPaint.left, rcPaint.top, rcPaint.right-rcPaint.left, rcPaint.bottom-rcPaint.top, PATCOPY );
        //FillRect( dc, &rcPaint, br );

   SetBrushOrgEx( dc, rc.right - 7, rc.top, NULL );
        SetRect( &rcPaint, rc.right - 7, rc.top, rc.right, rc.bottom );
        PatBlt( dc, rcPaint.left, rcPaint.top, rcPaint.right-rcPaint.left, rcPaint.bottom-rcPaint.top, PATCOPY );
        //FillRect( dc, &rcPaint, br2 );

   SelectObject( dc, hOldBrush );
   SetBkColor( dc, color );

        DeleteObject( bmp );
        DeleteObject( bmp2 );
        DeleteObject( br );
        DeleteObject( br2 );

}

HB_FUNC( EXTCREATEPEN )
{
   int numValues = 0;
   HPEN pen;
   LOGBRUSH lb;
   lb.lbStyle = BS_SOLID;
   lb.lbColor = (COLORREF)hb_parnl( 2 );
   lb.lbHatch = 0;

   pen = ExtCreatePen(PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_SQUARE | PS_JOIN_BEVEL, hb_parni( 1 ), &lb, numValues, NULL);

   hb_retnl( (long) pen );
}


    void GradientFill95( HDC hDC, RECT rct, COLORREF crStart, COLORREF crEnd, int bVertical )
    {
    	// Get the starting RGB values and calculate the incremental
    	// changes to be applied.

            int nSegments = 100;
    	COLORREF cr;
    	int nR = GetRValue(crStart);
    	int nG = GetGValue(crStart);
    	int nB = GetBValue(crStart);

    	int neB = GetBValue(crEnd);
    	int neG = GetGValue(crEnd);
    	int neR = GetRValue(crEnd);


    	int nDiffR = (neR - nR);
    	int nDiffG = (neG - nG);
    	int nDiffB = (neB - nB);

    	int ndR = 256 * (nDiffR) / (max(nSegments,1));
    	int ndG = 256 * (nDiffG) / (max(nSegments,1));
    	int ndB = 256 * (nDiffB) / (max(nSegments,1));

    	int nCX = (rct.right-rct.left) / max(nSegments,1);
    	int nCY = (rct.bottom-rct.top) / max(nSegments,1);
    	int nTop = rct.top;
    	int nBottom = rct.bottom;
    	int nLeft = rct.left;
    	int nRight = rct.right;

            HPEN hPen;
            HPEN hOldPen;
            HBRUSH hBrush;
            HBRUSH pbrOld;

            int i;

    	if(nSegments > ( rct.right - rct.left ) )
    		nSegments = ( rct.right - rct.left );


    	nR *= 256;
    	nG *= 256;
    	nB *= 256;

    	hPen    = CreatePen( PS_NULL, 1, 0 );
    	hOldPen = (HPEN) SelectObject( hDC, hPen );

    	for (i = 0; i < nSegments; i++, nR += ndR, nG += ndG, nB += ndB)
    	{
    		// Use special code for the last segment to avoid any problems
    		// with integer division.

    		if (i == (nSegments - 1))
    		{
    			nRight  = rct.right;
    			nBottom = rct.bottom;
    		}
    		else
    		{
    			nBottom = nTop + nCY;
    			nRight = nLeft + nCX;
    		}

    		cr = RGB(nR / 256, nG / 256, nB / 256);

    		{

    			hBrush = CreateSolidBrush( cr );
    			pbrOld = (HBRUSH) SelectObject( hDC, hBrush );

    			if( bVertical )
    			   Rectangle(hDC, rct.left, nTop, rct.right, nBottom + 1 );
    			else
    			   Rectangle(hDC, nLeft, rct.top, nRight + 1, rct.bottom);

    			(HBRUSH) SelectObject( hDC, pbrOld );
    			DeleteObject( hBrush );
    		}

    		// Reset the left side of the drawing rectangle.

    		nLeft = nRight;
    		nTop = nBottom;
    	}

    	(HPEN) SelectObject( hDC, hOldPen );
    	DeleteObject( hPen );
    }

// hDC, aRect, nClr1, nClr2
// Utilizar mejor C5Degrada
    HB_FUNC( DEGRADA95 )
    {
            RECT rct;

            rct.top    = hb_parvni( 2, 1 );
            rct.left   = hb_parvni( 2, 2 );
            rct.bottom = hb_parvni( 2, 3 );
            rct.right  = hb_parvni( 2, 4 );

            GradientFill95( ( HDC ) hb_parnl( 1 ) , rct, hb_parnl( 3 ), hb_parnl( 4 ), hb_parl(5) );

    }


HB_FUNC( CREATEBOLD )
{
        LOGFONT lf;
      GetObject( ( HFONT ) hb_parnl( 1 ) , sizeof( LOGFONT ), &lf );
      lf.lfWeight = FW_BOLD;
                  hb_retnl( (LONG) CreateFontIndirect( &lf ));
}


HB_FUNC( WBRWSCROLL ) // ( hWnd, nRows, hFont ) --> nil
{
   HWND hWnd   = ( HWND ) hb_parnl( 1 );
   int wRows  = hb_parni( 2 );
   HFONT hFont = ( HFONT ) hb_parnl( 3 );
   HFONT hOldFont;
   HDC hDC     = GetDC( hWnd );
   int nHLine = hb_parni( 4 );
   RECT rct;
   TEXTMETRIC tm;



   if( hFont )
      hOldFont = ( HFONT ) SelectObject( hDC, hFont );

   GetClientRect( hWnd, &rct );
   GetTextMetrics( hDC, &tm );
   if( hb_pcount() == 4 )
   {
      tm.tmHeight = nHLine;
   }
   else
   {
     tm.tmHeight += 1;
   }

   rct.top += tm.tmHeight;
   //rct.bottom -= ( ( rct.bottom - rct.top ) % tm.tmHeight );

   ScrollWindowEx( hWnd, 0, -( tm.tmHeight * wRows ), 0, &rct, 0, 0, 0 );

   if( hFont )
      SelectObject( hDC, hOldFont );

   ReleaseDC( hWnd, hDC );
}

HB_FUNC( DRAWFRAMECONTROL )
{
      RECT rc;
      rc.top    = hb_parvni( 2, 1);
      rc.left   = hb_parvni( 2, 2);
      rc.bottom = hb_parvni( 2, 3);
      rc.right  = hb_parvni( 2, 4);

       hb_retl( DrawFrameControl( (HDC) hb_parnl( 1 ), &rc, hb_parni( 3 ), hb_parni( 4 ) ) );
}




HB_FUNC( HWNDCOMBO )
{
   COMBOBOXINFO cbi      ;
   ZeroMemory( &cbi, sizeof( COMBOBOXINFO ) );
   cbi.cbSize = sizeof(COMBOBOXINFO);

   GetComboBoxInfo( (HWND) hb_parnl( 1 ), &cbi );

   hb_retnl( (LONG)cbi.hwndCombo ) ;
}

HB_FUNC( HWNDCOMBOEDIT )
{
   COMBOBOXINFO cbi      ;
   ZeroMemory( &cbi, sizeof( COMBOBOXINFO ) );
   cbi.cbSize = sizeof(COMBOBOXINFO);

   GetComboBoxInfo( (HWND) hb_parnl( 1 ), &cbi );

   hb_retnl( (LONG)cbi.hwndItem ) ;
   //hb_retnl( (LONG)cbi.hwndList ) ;
}

HB_FUNC( HWNDCOMBOLIST )
{
   COMBOBOXINFO cbi      ;
   ZeroMemory( &cbi, sizeof( COMBOBOXINFO ) );
   cbi.cbSize = sizeof(COMBOBOXINFO);

   GetComboBoxInfo( (HWND) hb_parnl( 1 ), &cbi );

   hb_retnl( (LONG)cbi.hwndList ) ;
}
// no funciona en w95 revisar GetComboBoxInfo


HB_FUNC( GETDEFAULTFONTNAME )
{
      LOGFONT lf;
      GetObject( ( HFONT ) GetStockObject( DEFAULT_GUI_FONT )  , sizeof( LOGFONT ), &lf );
      hb_retc( lf.lfFaceName );

}

HB_FUNC( GETDEFAULTFONTHEIGHT )
{
      LOGFONT lf;
      GetObject( ( HFONT ) GetStockObject( DEFAULT_GUI_FONT )  , sizeof( LOGFONT ), &lf );
      hb_retni( lf.lfHeight );
}

HB_FUNC( GETDEFAULTFONTWIDTH )
{
      LOGFONT lf;
      GetObject( ( HFONT ) GetStockObject( DEFAULT_GUI_FONT )  , sizeof( LOGFONT ), &lf );
      hb_retni( lf.lfWidth );
}

HB_FUNC( GETDEFAULTFONTITALIC )
{
      LOGFONT lf;
      GetObject( ( HFONT ) GetStockObject( DEFAULT_GUI_FONT )  , sizeof( LOGFONT ), &lf );
      hb_retl( (BOOL) lf.lfItalic );
}

HB_FUNC( GETDEFAULTFONTUNDERLINE )
{
      LOGFONT lf;
      GetObject( ( HFONT ) GetStockObject( DEFAULT_GUI_FONT )  , sizeof( LOGFONT ), &lf );
      hb_retl( (BOOL) lf.lfUnderline );
}

HB_FUNC( GETDEFAULTFONTBOLD )
{
      LOGFONT lf;
      GetObject( ( HFONT ) GetStockObject( DEFAULT_GUI_FONT )  , sizeof( LOGFONT ), &lf );
      hb_retl( (BOOL) ( lf.lfWeight == 700 ) );
}

HB_FUNC( GETDEFAULTFONTSTRIKEOUT )
{
      LOGFONT lf;
      GetObject( ( HFONT ) GetStockObject( DEFAULT_GUI_FONT )  , sizeof( LOGFONT ), &lf );
      hb_retl( (BOOL) lf.lfStrikeOut );
}

HB_FUNC( XDLGUNITS )
{
   HDC dc = GetDC(NULL);
   HFONT hFont = (HFONT) hb_parnl( 1 );
   LOGFONT lf, lf2;
   HFONT hSysFont;
   TEXTMETRIC tm;
   int cx, cxSys;
   int avgWidth, avgWidthSys;
   int basex;

   HFONT hOldFont = (HFONT)SelectObject(dc, hFont);
   GetObject( ( HFONT ) hFont  , sizeof( LOGFONT ), &lf );
   GetTextMetrics(dc, &tm);
   GetTextExtentPoint32(dc,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",52,&cx);
   SelectObject(dc, hOldFont);

   GetObject( ( HFONT ) GetStockObject( DEFAULT_GUI_FONT )  , sizeof( LOGFONT ), &lf2 );
   //GetObject( ( HFONT ) GetStockObject( SYSTEM_FONT )  , sizeof( LOGFONT ), &lf );
   lf2.lfWidth = lf.lfWidth;
   lf2.lfHeight = lf.lfHeight;
   hSysFont = CreateFontIndirect( &lf2 );
   hOldFont = (HFONT) SelectObject( dc, hSysFont );
   GetTextExtentPoint32(dc,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",52,&cxSys);
   SelectObject(dc, hOldFont);
   DeleteObject( hSysFont );
   ReleaseDC(NULL, dc);

   avgWidth = (cx/(26+1))/2;
   avgWidthSys = (cxSys/(26+1))/2;

   basex = ( 2*avgWidth/avgWidthSys );
   hb_retni(basex);
}

HB_FUNC( YDLGUNITS )
{
   HDC dc = GetDC(NULL);
   HFONT hFont = (HFONT) hb_parnl( 1 );
   HFONT hSysFont;
   LOGFONT lf, lf2;
   TEXTMETRIC tm, tm2;
   int basey;

   HFONT hOldFont = (HFONT)SelectObject(dc, hFont);
   GetTextMetrics(dc, &tm);
   SelectObject(dc, hOldFont);

   GetObject( ( HFONT ) hFont  , sizeof( LOGFONT ), &lf );
   GetObject( ( HFONT ) GetStockObject( SYSTEM_FONT )  , sizeof( LOGFONT ), &lf2 );
   lf2.lfWidth = lf.lfWidth;
   lf2.lfHeight = lf.lfHeight;
   hSysFont = CreateFontIndirect( &lf2 );
   hOldFont = (HFONT)SelectObject(dc, hSysFont);
   GetTextMetrics(dc, &tm2);
   SelectObject(dc, hOldFont);
   DeleteObject( hSysFont );

   ReleaseDC(NULL, dc);
   basey = (2*tm.tmHeight/tm2.tmHeight);
   hb_retni( basey );
}

HB_FUNC( XYDLGUNITS )
{
   int avgWidth, avgHeight;
   HDC dc = GetDC(NULL);
   HFONT hFontOld = (HFONT)SelectObject(dc,(HFONT)hb_parnl( 1 ));
   SIZE size;
   TEXTMETRIC tm;

   GetTextMetrics(dc,&tm);
   GetTextExtentPoint32(dc,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",52,&size);
   avgWidth = (size.cx/26+1)/2;
   avgHeight = (WORD)tm.tmHeight;
   SelectObject(dc,hFontOld);
   ReleaseDC(NULL, dc);
   hb_reta(2);
   hb_storvni( avgWidth, -1, 1 );
   hb_storvni( avgHeight, -1, 2 );
}

 /*
HB_FUNC(  GETPTSIZE ) //( HDC &dc, HFONT &font, SIZE *pSize )
{
    HFONT oldfont = 0;
    HDC dc = GetDC(NULL);
    static char *sym = "abcdefghijklmnopqrstuvwxyz"
                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    SIZE sz;
    sz.cx = hb_parni( 2 );
    sz.cy = hb_parni( 3 );
    TEXTMETRICA t;
    oldfont = (HFONT)SelectObject(dc,hb_parnl(1));
    GetTextMetricsA(dc,&t);
    GetTextExtentPointA(dc,sym, 52, &sz);
    pSize->cy = t.tmHeight;
    pSize->cx = (sz.cx / 26 + 1) / 2;
    SelectObject(dc,oldfont);
}
*/

HB_FUNC ( DRIVETYPE )
{
   #if defined(HB_OS_WIN_32)
      unsigned int uiType;
      char * pDrive = (char *) hb_xgrab( hb_parclen( 1 )+3 ); // allow space for '\0' & ":\"
      strcpy( pDrive, (char *) hb_parcx(1) );

      if ( strstr( pDrive, ":" ) == NULL )
      {
         strcat( pDrive, ":" ) ;
      }

      if ( strstr( pDrive, "\\" ) == NULL )
      {
         strcat( pDrive, "\\" ) ;
      }

      uiType = GetDriveType( pDrive );

      if ( uiType  == DRIVE_RAMDISK )
      {
         hb_retni( 0 );  // RAM Drive - Clipper compatible
      }
      else if (uiType == DRIVE_REMOVABLE )
      {
         hb_retni( 2 );  // Floppy Drive - Clipper compatible
      }
      else if (uiType == DRIVE_FIXED )
      {
         hb_retni( 3 );  // Hard Drive  - Clipper compatible
      }
      else if (uiType == DRIVE_CDROM )
      {
         hb_retni( 4 );  // CD-Rom Drive - xHarbour extension
      }
      else if (uiType == DRIVE_REMOTE )
      {
         hb_retni( 5 );  // Network Drive - xHarbour extension
      }
      else
      {
         hb_retni( 9 );  // Unknow Drive - xHarbour extension
      }
      hb_xfree( pDrive );
   #else
      hb_retni(9);
   #endif

}

HB_FUNC( GETBMPICONEXT )
{

   SHFILEINFO    sfi;
   HDC dcMem;
   HDC hDC;
   HBITMAP bmpMem, hOldBmp;
   RECT rct;
   COLORREF nColor;

	SHGetFileInfo(
		   hb_parc( 1 ),
		   FILE_ATTRIBUTE_NORMAL,
		   &sfi,
		   sizeof(SHFILEINFO),
		   SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES);


   hDC = CreateDC( "DISPLAY","","",NULL);

   dcMem = CreateCompatibleDC( hDC );
   bmpMem = CreateCompatibleBitmap( hDC, 16, 16 );
   hOldBmp = (HBITMAP) SelectObject( dcMem, bmpMem );
   rct.top    = 0;
   rct.left   = 0;
   rct.bottom = 16;
   rct.right  = 16;

   nColor = SetBkColor( dcMem, RGB(255,255,255) );
   ExtTextOut( dcMem, 0, 0, ETO_OPAQUE, &rct, NULL, 0, NULL);
   SetBkColor( dcMem, nColor );

   DrawIconEx( dcMem, 0, 0, sfi.hIcon, 16, 16, NULL, NULL, DI_NORMAL );
   DestroyIcon( sfi.hIcon );
   SelectObject( dcMem, hOldBmp );
   DeleteDC( dcMem );
   DeleteDC( hDC );
   hb_retnl( (LONG) bmpMem );
}

HB_FUNC( SETSTRETCHBLTMODE )
{
   hb_retni( SetStretchBltMode( (HDC) hb_parnl( 1 ), hb_parni( 2 ) ) ) ;
}

void DrawBitmapEx( HDC hdc, HBITMAP hbm, WORD wCol, WORD wRow, WORD wWidth,
                 WORD wHeight, DWORD dwRaster )
{
    HDC       hDcMem, hDcMemX;
    BITMAP    bm, bmx;
    HBITMAP   hBmpOld, hbmx, hBmpOldX;

    if( !hdc || !hbm )
       return;

    hDcMem  = CreateCompatibleDC( hdc );
    hBmpOld = ( HBITMAP ) SelectObject( hDcMem, hbm );

    if( ! dwRaster )
       dwRaster = SRCCOPY;

    GetObject( hbm, sizeof( BITMAP ), ( LPSTR ) &bm );

    if( ! wWidth || ! wHeight )
       BitBlt( hdc, wRow, wCol, bm.bmWidth, bm.bmHeight, hDcMem, 0, 0, dwRaster );
    else
    {
       hDcMemX          = CreateCompatibleDC( hdc );
       bmx              = bm;
       bmx.bmWidth      = wWidth;
       bmx.bmHeight     = wHeight;

       bmx.bmWidthBytes = ( bmx.bmWidth * bmx.bmBitsPixel + 15 ) / 16 * 2;

       hbmx = CreateBitmapIndirect( &bmx );

       SetStretchBltMode (hDcMemX, COLORONCOLOR);
       hBmpOldX = ( HBITMAP ) SelectObject( hDcMemX, hbmx );
       StretchBlt( hDcMemX, 0, 0, wWidth, wHeight, hDcMem, 0, 0,
                   bm.bmWidth, bm.bmHeight, dwRaster );
       BitBlt( hdc, wRow, wCol, wWidth, wHeight, hDcMemX, 0, 0, dwRaster );
       SelectObject( hDcMemX, hBmpOldX );
       DeleteDC( hDcMemX );
       DeleteObject( hbmx );
    }

    SelectObject( hDcMem, hBmpOld );
    DeleteDC( hDcMem );
}
HB_FUNC( DRAWBITMAPEX ) //  hDC, hBitmap, nRow, nCol, nWidth, nHeight, nRaster
{
   DrawBitmapEx( ( HDC ) hb_parnl( 1 ), ( HBITMAP ) hb_parnl( 2 ),
               hb_parni( 3 ), hb_parni( 4 ),
               hb_parni( 5 ), hb_parni( 6 ), hb_parnl( 7 ) );
}


   HB_FUNC( MULDIV )
   {
      hb_retni( MulDiv( hb_parni( 1 ), hb_parni( 2 ), hb_parni( 3 ) ) );
   }


HB_FUNC( SETSCROLLRANGE )
{
   hb_retl( SetScrollRange( (HWND) hb_parnl( 1 ),
                            hb_parni( 2 )       ,
                            hb_parni( 3 )       ,
                            hb_parni( 4 )       ,
                            hb_parl( 5 )
                          ) ) ;
}

HB_FUNC( GETSCROLLINFOPOS )
{
   SCROLLINFO si ;
   si.cbSize = sizeof(SCROLLINFO) ;
   si.fMask  = SIF_TRACKPOS ;

   if ( GetScrollInfo( (HWND) hb_parnl( 1 ), hb_parni( 2 ), &si ) )
      hb_retni( si.nTrackPos );
   else
      hb_retni( 0 );

}


HB_FUNC( SUMAESTILO )
{
   int i;
   int style = hb_parnl( 2 );

   for ( i = 3; i <= hb_pcount(); i++ )
      style = style | hb_parnl( i );

   SetWindowLong( (HWND) hb_parnl( 1 ), GWL_STYLE, style );
}

//--------------------------------------------------------------------------

HB_FUNC( RESTAESTILO )
{
   int i;
   int style = hb_parnl( 2 );

   for ( i = 3; i <= hb_pcount(); i++ )
      style = style & ~hb_parnl( i );

   SetWindowLong( (HWND) hb_parnl( 1 ), GWL_STYLE, style );
}

HB_FUNC( SUMAESTILOEXTENDIDO )
{
   int i;
   int style = hb_parnl( 2 );

   for ( i = 3; i <= hb_pcount(); i++ )
      style = style | hb_parnl( i );

   SetWindowLong( (HWND) hb_parnl( 1 ), GWL_EXSTYLE, style );

}

//--------------------------------------------------------------------------

HB_FUNC( RESTAESTILOEXTENDIDO )
{
   int i;
   int style = hb_parnl( 2 );

   for ( i = 3; i <= hb_pcount(); i++ )
      style = style & ~hb_parnl( i );

   SetWindowLong( (HWND) hb_parnl( 1 ), GWL_EXSTYLE, style );
}


//HB_FUNC( LINE )
//{
//   HDC hDC = (HDC) hb_parnl( 1 );
//   int nTop = hb_parni( 2 );
//   int nLeft = hb_parni( 3 );
//   int nBottom = hb_parni( 4 );
//   int nRight = hb_parni( 5 );
//   COLORREF color = (COLORREF) hb_parnl(6);
//   HPEN hPen, hOldPen;
//   hPen = CreatePen( PS_SOLID, 1, color );
//   hOldPen = (HPEN) SelectObject( hDC, hPen );
//   MoveToEx( hDC, nLeft, nTop, NULL );
//   LineTo( hDC, nRight, nBottom );
//   SelectObject( hDC, hOldPen );
//   DeleteObject( hPen );
//}
//
//

HB_FUNC( ALPHABLEND )
{

}


HB_FUNC( FREELIBRARY ) // ( hDll ) --> nil
{
   hb_retnl( FreeLibrary( ( HINSTANCE ) hb_parnl( 1 ) ) );
}

//---------------------------------------------------------------------------//

HB_FUNC( LOADLIBRARY ) // ( cDllName ) --> hDll
{
   hb_retnl( ( LONG ) LoadLibrary( hb_parc( 1 ) ) );
}

#pragma ENDDUMP





function curdrive() ; return hb_curdrive()


_HB_CLASS TWindowMain ; function TWindowMain ( ... ) ; static s_oClass ; local nScope, oClass, oInstance ; if s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; begin sequence ; nScope := 1 ; ( ( nScope ) ) ; oClass := IIF(.F.,, HBClass():new( "TWindowMain" , iif( .T., { @TWindow() }, { @HBObject() } ), @TWindowMain() ) ) ;

      _HB_MEMBER { AS LOGICAL lRegistered } ; oClass:AddMultiClsData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRegistered"}, .F. )

      _HB_MEMBER HandleEvent( nMsg, nWParam, nLParam); oClass:AddMethod( "HandleEvent", @TWindowMain_HandleEvent(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; oInstance := oClass:Instance() ; if __ObjHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; end ; always ; __clsUnlockDef( @s_oClass, oClass ) ; end ; return oInstance ; end ; return s_oClass:Instance() AS CLASS TWindowMain ;

static FUNCTION TWindowMain_HandleEvent( nMsg, nWParam, nLParam ) ; local Self AS CLASS TWindowMain := QSelf() AS CLASS TWindowMain

if nMsg == 28




endif

return ::TWindow:HandleEvent( nMsg, nWParam, nLParam )



   function VisorCodigo()



  oWndCode := TWindow():New( 10, 500, 310, 1200, "Visor code",,,,,,,,,,,, !.F., !.F., !.F., !.F., .T. )
























      oCode := TScintilla():New(0, 0, 1, 1, oWndCode )
      oCode:SetFocus()

      oWndCode:oClient := oCode
      oWndCode:ToolWindow()
      oWndCode:Show()




return nil

function oWndCode() ; return oWndCode
