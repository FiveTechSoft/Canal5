#line 38 "\fwh\include\FiveWin.ch"
      static bError
#line 219 "hbclass.ch"
DECLARE HBClass  New( cName AS STRING, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS OBJECT  Instance() AS OBJECT  AddClsMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC, n2 AS NUMERIC, n3 AS NUMERIC )  AddMultiClsData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING )  AddMultiData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC )  AddInLine( cName AS STRING, bBlock AS CODEBLOCK, nScope AS NUMERIC )  AddVirtual( cName AS STRING )
#line 79 "\fwh\include\FiveWin.ch"
         EXTERNAL FW_GT











extern errorsys
#line 88 "source\listpropex.prg"
extern DBSKIP

static aCLient






















static oWnd1
static oCbxComponentes



function ListPropEx()
local hDC, aFonts

local oList
local nGroup
local oFont
local oBar
local oMenu
local cVar := ""
local aItems := {}

oFont := TFont():New( "Verdana", 0, -11,,,,,,,,,,,,,, )







oWnd1 := TWindow():New( Aplicacion():nTopProp, Aplicacion():nLeftProp, Aplicacion():nBottomProp, Aplicacion():nRightProp, "Properties",,,,,,,,,,,, !.F., !.F., !.F., !.F., .T. )
Aplicacion():oInspector := oWnd1
oWnd1:ToolWindow()

oCbxComponentes := TComboBox():New( 0, 0, { | u | If( PCount()==0, cVar, cVar:= u ) }, aItems, 300, 400, oWnd1,,,,,, .T., oFont,, .F.,, .F.,,,,, )




oList := TListPropEx():New( 2, 2, 300, 500, , {"","",""},  {20, 100, 100}, oWnd1, , , ,, ,, oFont )





oList:nLineStyle := 2
























































oWnd1:oTop := oCbxComponentes
oWnd1:oClient := oList
oWnd1:Resize()
oWnd1:Show()




return oList






_HB_CLASS TListPropEx ; function TListPropEx ( ... ) ; static s_oClass ; local nScope, oClass, oInstance ; if s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; begin sequence ; nScope := 1 ; ( ( nScope ) ) ; oClass := IIF(.F.,, HBClass():new( "TListPropEx" , iif( .T., { @TWBrowse2() }, { @HBObject() } ), @TListPropEx() ) ) ;

      _HB_MEMBER { AS LOGICAL lRegistered } ; oClass:AddMultiClsData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRegistered"}, .F. )

; _HB_MEMBER { aItems } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aItems"}, .F. )
; _HB_MEMBER { hMinus } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hMinus"}, .F. )
; _HB_MEMBER { hPlus } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"hPlus"}, .F. )
; _HB_MEMBER { nTipoSort } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nTipoSort"}, .F. )
; _HB_MEMBER { nGrupos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nGrupos"}, .F. )
; _HB_MEMBER { nItem } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nItem"}, .F. )
; _HB_MEMBER { aRectBtn } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aRectBtn"}, .F. )
; _HB_MEMBER { oObject } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oObject"}, .F. )
; _HB_MEMBER { oDlg } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oDlg"}, .F. )






      _HB_MEMBER New( nRow, nCol, nWidth, nHeigth, bLine, aHeaders,  aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nForeBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions) AS CLASS TListPropEx; oClass:AddMethod( "New", @TListPropEx_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER AddGroup(); oClass:AddInline( "AddGroup", {|Self, cGroup | ( ( Self ) ), ::AddItem( ,cGroup,"G",++::nGrupos), ::nGrupos }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER AddItem( cVARNAME, cText, nTipo, nGroup, lAbierto, lEnable, bAction); oClass:AddMethod( "AddItem", @TListPropEx_AddItem(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER GetLine(); oClass:AddMethod( "GetLine", @TListPropEx_GetLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER nGetElement( n); oClass:AddMethod( "nGetElement", @TListPropEx_nGetElement(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER CalcLen(); oClass:AddMethod( "CalcLen", @TListPropEx_CalcLen(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Open( lOpen); oClass:AddMethod( "Open", @TListPropEx_Open(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER OpenClose( nRow, nCol); oClass:AddMethod( "OpenClose", @TListPropEx_OpenClose(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Click( nRow, nCol); oClass:AddMethod( "Click", @TListPropEx_Click(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER Teclas( nKey, nFlags); oClass:AddMethod( "Teclas", @TListPropEx_Teclas(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



      _HB_MEMBER wBrwLine( hWnd, hDC, nRowPos, aValues, aColSizes, nColPos, nClrText, nClrPane, hFont, lTree, aJustify, nPressed, nLineStyle, nColAct, lFocused, oVScroll, bLogicLen, lBar); oClass:AddMethod( "wBrwLine", @TListPropEx_wBrwLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER PaintBtn( hDC, aRect, nItem); oClass:AddMethod( "PaintBtn", @TListPropEx_PaintBtn(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Sort(); oClass:AddMethod( "Sort", @TListPropEx_Sort(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER OpenAll(); oClass:AddMethod( "OpenAll", @TListPropEx_OpenAll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER CloseAll(); oClass:AddMethod( "CloseAll", @TListPropEx_CloseAll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER EditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction); oClass:AddMethod( "EditCol", @TListPropEx_EditCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER GetAction( nItem); oClass:AddMethod( "GetAction", @TListPropEx_GetAction(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER SetInspect( oObject); oClass:AddMethod( "SetInspect", @TListPropEx_SetInspect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER aGetRectSel(); oClass:AddMethod( "aGetRectSel", @TListPropEx_aGetRectSel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; oInstance := oClass:Instance() ; if __ObjHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; end ; always ; __clsUnlockDef( @s_oClass, oClass ) ; end ; return oInstance ; end ; return s_oClass:Instance() AS CLASS TListPropEx ;





static FUNCTION TListPropEx_New( nRow, nCol, nWidth, nHeigth, bLine, aHeaders,  aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nForeBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local o := self
local oBar

If( bValid == nil, bValid := {||.T.}, ) ;





       ::TWBrowse2:New( nRow, nCol, nWidth, nHeigth, bLine, {"","",""},  aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nForeBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions )

       ::nItem     := 0
       ::nGrupos   := 0
       ::aItems    := {}
       ::aHeaders  := {"","",""}
       ::aColSizes := {20, 130, 160}
       ::aJustify  := {.F., .F., .F.}
       ::bLogicLen := {|| o:CalcLen() }
       ::nAt := 0
       ::bGoTop    = { || ::nAt := 1 }
       ::bGoBottom = { || ::nAt := Eval( ::bLogicLen, Self ) }


       ::bSkip     = { | nSkip, nOld | nOld := ::nAt, ::nAt += nSkip, ::nAt := Min( Max( ::nAt, 1 ), Eval( ::bLogicLen, Self ) ), ::nAt - nOld }
       ::hMinus := LoadBitmap( GetResources(), "minus" )
       ::hPlus  := LoadBitmap( GetResources(), "plus" )
       ::bKeyDown := {|nKey, nFlags| o:Teclas( nKey, nFlags ) }

       ::bLine := {|| o:GetLine() }
       ::bLClicked := {|nRow,nCol| o:Click( nRow, nCol ) }
       ::bLDblClick := {|nRow,nCol| o:Click( nRow, nCol ) }
       ::bChange := {|| if( o:oGet <> nil, o:oGet:End(), .T.) }
       ::nTipoSort := 1

       oBar := TBar():New( SELF, 21, 20, .F.,,, .F., .F. )
       ::oBrush:End()
       oBar:SetColor( 0, ( 240 + ( 240 * 256 ) + ( 240 * 65536 ) ))

          TBtnBmp():NewBar( "btn1",,,,, {|This|( o:nTipoSort := 1,::Sort(), ::GoTop(),o:SetFocus(),o:Refresh())}, .T., oBar, .F.,, "Categorias", .F.,, "( o:nTipoSort := 1,::Sort(), ::GoTop(),o:SetFocus(),o:Refresh())",,,,,, !.T.,,,,, .F. )
          TBtnBmp():NewBar( "btn2",,,,, {|This|( o:nTipoSort := 2,::Sort(), ::GoTop(),o:SetFocus(),o:Refresh())}, .T., oBar, .F.,, "Alfabético", .F.,, "( o:nTipoSort := 2,::Sort(), ::GoTop(),o:SetFocus(),o:Refresh())",,,,,, !.T.,,,,, .F. )
          TBtnBmp():NewBar( "btn3",,,,,, .T., oBar, .F.,, "Propiedades", .F.,,,,,,,, !.T.,,,,, .F. )
          TBtnBmp():NewBar( "btn4",,,,,, .T., oBar, .F.,, "Eventos", .F.,,,,,,,, !.T.,,,,, .F. )
          TBtnBmp():NewBar( "plus",,,,, {|This|::OpenAll()}, .T., oBar, .F.,, "Abrir todas", .F.,, "::OpenAll()",,,,,, !.T.,,,,, .F. )
          TBtnBmp():NewBar( "minus",,,,, {|This|::CloseAll()}, .F., oBar, .F.,, "Cerrar todas", .F.,, "::CloseAll()",,,,,, !.T.,,,,, .F. )

          ::oHScroll:SetRange(1,1)

       ::aRectBtn := {}


return self




  static FUNCTION TListPropEx_Sort( ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx


if ::nTipoSort == 1
   ::aItems := ASORT(::aItems,,, { |x, y| x:nItem < y:nItem })
else
   ::aItems := ASORT(::aItems,,, { |x, y| x:cText < y:cText })
endif

return nil


    static FUNCTION TListPropEx_aGetRectSel( ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nTop, nLeft, nBottom, nRight


   nTop    := (::nRowPos)*::nHLine
   nLeft   := ::aColSizes[1]+::aColsizes[2]
   nBottom := nTop + ::nHLine
   nRight  := nLeft + ::aColSizes[3]+1
return {nTop, nLeft, nBottom, nRight}



   static FUNCTION TListPropEx_AddItem( cVARNAME, cText, nTipo, nGroup, lAbierto, lEnable, bAction, bEditor ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

If( lAbierto == nil, lAbierto := .T., ) ;
If( nTipo == nil, nTipo := "", ) ;
If( nGroup == nil, nGroup := 1, ) ;
If( lEnable == nil, lEnable := .T., ) ;
If( bAction == nil, bAction := {||.F.}, ) ;

::nItem += 5

aadd( ::aItems, TProperty():New( ::oObject, cVarName,  cText, bAction,   nTipo, lEnable, lAbierto, bEditor, ::nItem, nGroup ) )



return nil




      static FUNCTION TListPropEx_GetLine( ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local aLine := {"",""}
local nItem := ::nGetElement( ::nAt )
local oProp

if nItem == 0
   return nil
endif

oProp := ::aItems[nItem]

if oProp:cType == "G"
   aLine := {if(oProp:lOpen,::hMinus,::hPlus), oProp:cText, cValToChar(oProp:Get()) }
else
   if !empty( oProp:cProperty )
      aLine := {0, oProp:cText, cValToChar( oProp:Get() ) }
   else
      aLine := {0, oProp:cText,"" }
   endif
endif

return aLine



      static FUNCTION TListPropEx_nGetElement( n ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nLenItems := len( ::aItems )
local nCount := 0
local lOpened := .T.
local nItem
local lGrupo
local oProp

if ::nTipoSort == 1
   for nItem := 1 to nLenItems
       oProp := ::aItems[nItem]

       if oProp:cType == "G"
          nCount++
          lOpened := oProp:lOpen
       else
          if lOpened
             nCount++
          endif
       endif
       if nCount == n
          return nItem
       endif
    next
else
   for nItem := 1 to nLenItems
       oProp := ::aItems[nItem]
       if oProp:cType <> "G"
          nCount++
       endif
       if nCount == n
          return nItem
       endif
    next
endif

return 0


      static FUNCTION TListPropEx_CalcLen( ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nLen := len( ::aItems )
local nCount := 0
local nGroup := 0
local lOpened := .T.
local nItem
local oProp

if nLen == 0
   return 0
endif

if ::nTipoSort == 2
   nCount = nLen - ::nGrupos
else
   for nItem := 1 to nLen
       oProp := ::aItems[nItem]
       if oProp:cType == "G"
          nCount++
          lOpened := oProp:lOpen
       else
          if lOpened
             nCount++
          endif
       endif
   next
endif

return nCount




   static FUNCTION TListPropEx_Open( lOpen ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nItem := ::nGetElement( ::nAt )
local oProp

If( lOpen == nil, lOpen := .T., ) ;

if len( ::aItems ) < 1
   return nil
endif

oProp := ::aItems[nItem]

if oProp:cType <> "G"
   return nil
endif

oProp:lOpen := lOpen
::Refresh()


return nil


   static FUNCTION TListPropEx_OpenClose( nRow, nCol ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nItem := ::nGetElement( ::nAt )
local lOpen := .T.
local oProp

if len( ::aItems ) < 1
   return nil
endif
oProp := ::aItems[nItem]

if oProp:cType <> "G"
   return nil
endif


if nCol <> nil
   if nCol <= ::aColsizes[1]
      oProp:lOpen := !::aItems[nItem, 6 ]
      ::Refresh()
   endif

endif

return nil







   static FUNCTION TListPropEx_Click( nRow, nCol ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nItem := ::nGetElement( ::nAt )
local aRect, oLbx, cVar, aItems
local oDlg, aPos
local o := self
local oFont
local bValid := {||.T.}
local cType := "A"
local uVar
local hDC
local oProp



if nItem <= 0 .OR. nItem > len( ::aItems )
   return 0
endif

oProp := ::aItems[nItem]

if oProp:lEnable

   if !empty( ::aRectBtn )
      ReleaseCapture()
      if PtInRect( nRow, nCol, ::aRectBtn ) .OR. nRow < 0
         do case
            case oProp:cType == "L"

                 uVar := !oProp:Get()

                 ::DrawSelect()

                 oProp:Set( uVar )

                 ::oObject:Refresh()
                 ::Refresh()

            case oProp:cType == "A"

                 aRect := ::aGetRectSel()

                 if oProp:bProperty <> NIL
                    aItems := eval( oProp:bProperty )
                    cVar := aItems[1]
                 else
                    aItems := {"unnamed"}
                    cVar := "unnamed"
                 endif

                 oFont := TFont():New( "Tahoma", 10, aRect[3]-aRect[1]-8,,,,,,,,,,,,,, )

                 ::oGet := TComboBox():New( aRect[1], aRect[2], { | u | If( PCount()==0, cVar, cVar:= u ) }, aItems, aRect[4]-aRect[2], 510, o,,,,,, .T., oFont,, .F.,, .F.,,, 2,, )
                 SetFocus( ::oGet:hWnd )

                 uVar := cVar



                 ::oGet:bLostFocus := {|| ::oGet:VarPut( If( cType == "L", ( uVar == aItems[ 1 ] ), ::oGet:VarGet() ) ) , If( Self:nLastKey <> 27, Eval( bValid, uVar, Self:nLastKey, Self ), Eval( bValid, nil, Self:nLastKey, Self ) ), oProp:Set(::oGet:VarGet()),::oGet:End(), ::oObject:Refresh() }

                 ::oGet:bKeyDown := { | nKey | If( nKey == 13 .OR. nKey == 27,( Self:nLastKey := nKey, oProp:Set(::oGet:VarGet()),::oGet:End(),o:SetFocus(), ::oObject:Refresh()), 1  ) }


                 SendMessage( HWNDCOMBOEDIT( ::oGet:hWnd ), 48, ::oFont:hFont, 0 )
                 SendMessage( HWNDCOMBOLIST( ::oGet:hWnd ), 48, ::oFont:hFont, 0 )
                 SendMessage( ::oGet:hWnd , 335, 1, 0 )

            case oProp:cType == "B"

                 oProp:Set( eval( ::GetAction( nItem ) ) )
                 ::oObject:Refresh()
                 ::Refresh()
         endcase
      endif
   else
      if nCol > ::aColSizes[1]+::aColSizes[2] .AND. oProp:cType <> "G"
         ::EditCol( oProp:Get(), nItem )
      endif
   endif

endif

return .T.


   static FUNCTION TListPropEx_GetAction( nItem ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local bAction := ::aItems[nItem]:bProperty

If( bAction == nil, bAction := {|| .T.}, ) ;




return bAction


   static FUNCTION TListPropEx_Teclas( nKey, nFlags ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nItem := ::nGetElement(::nAt)
local oProp := ::aItems[nItem]
local lGrupo := oProp:cType == "G"

do case
   case nKey == 32
        if lGrupo
           oProp:lOpen := !::aItems[nItem, 6 ]
           ::Refresh()
        else
           if oProp:cType == "A"
              ::Click(-1)
           else
              if oProp:cType == "L"
                 ::Click( -1 )
                 ::DrawSelect()
              endif
           endif
        endif

   case nKey == 13 .OR. nKey == 115
       if oProp:cType == "A"
              ::Click(-1)
       endif
   case lGrupo .AND. nKey == 109
        if oProp:lOpen
           oProp:lOpen := .F.
           ::Refresh()
        endif
   case lGrupo .AND. nKey == 107
        if !oProp:lOpen
           oProp:lOpen := .T.
           ::Refresh()
        endif
endcase


return nil





static FUNCTION TListPropEx_wBrwLine( hWnd, hDC, nRowPos, aValues, aColSizes, nColPos, nClrText, nClrPane, hFont, lTree, aJustify, nPressed, nLineStyle, nColAct, lFocused, oVScroll, bLogicLen, lBar ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx


local nItem, aRect
local lGrupo := .F.
local lHDC := .F.
local oProp

If( lBar == nil, lBar := .F., ) ;




::TWBrowse2:wBrwLine( hWnd, hDC, nRowPos, aValues, aColSizes, nColPos, nClrText, nClrPane, hFont, lTree, aJustify, nPressed, nLineStyle, nColAct, lFocused, oVScroll, bLogicLen, lBar )


if lBar

   nItem := ::nGetElement( ::nAt )

   oProp := ::aItems[nItem]

   if !oProp:lEnable
      return nil
   endif

   aRect := GetClientRect( ::hWnd )

   if ::hDC == nil
      ::hDC := ::GetDC()
      lHDC := .T.
   endif

   aRect[1] := (nRowPos)*::nHLine
   aRect[3] := aRect[1]+::nHLine
   aRect[4] := aRect[4]-1

   ::PaintBtn( ::hDC, aRect, nItem )

   if lHDC
      ::ReleaseDC()
   endif

endif

return nil




  static FUNCTION TListPropEx_PaintBtn( hDC, aRect, nItem ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local oProp := ::aItems[nItem]
local hBmp
local nMedH := (aRect[3]-aRect[1]) / 2
local nMedW := (aRect[4]-aRect[2]) / 2
local nTop  := aRect[1] + nMedH
local nLeft := aRect[4] - 20


aRect[2] := aRect[4]-( aRect[3]-aRect[1])
do case
   case oProp:cType == "L"

        aRect[1] := nTop  - 7
        aRect[2] := nLeft - 7
        aRect[3] := nTop  + 7
        aRect[4] := nLeft + 7

        DrawFrameControl( hDC, aRect, 4, if(oProp:Get(),1024,0)  )
        ::aRectBtn := aRect

   case oProp:cType == "A"

        aRect[1]+=1
        aRect[2]+=1
        aRect[3]-=1
        aRect[4]-=1
        aRect[2] := aRect[4]-18

        hBmp := LoadBitmap( , 32738 )
        DrawFrameControl( hDC, aRect, 4, 16 )
        DrawMasked( hDC, hBmp, nTop -5, aRect[2]+3 )

        DeleteObject( hBmp )
        ::aRectBtn := aRect

   case oProp:cType == "B"

        DrawFrameControl( hDC, aRect, 4, 16 )
        SetBkMode( hDC, 1 )
        TextOut( hDC, aRect[1]+2, aRect[2]+5, "...")
        ::aRectBtn := aRect

   otherwise

        ::aRectBtn := {}

endcase

return nil

      static FUNCTION TListPropEx_OpenAll( ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nItem
for nItem := 1 to len( ::aItems )
    if ::aItems[nItem] == "G"
       ::aItems[nItem]:lOpen := .T.
    endif
next
::GoTop()
::Refresh()

return nil

      static FUNCTION TListPropEx_CloseAll( ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local nItem
for nItem := 1 to len( ::aItems )
    if ::aItems[nItem] == "G"
       ::aItems[nItem]:lOpen := .F.
    endif
next
::GoTop()
::Refresh()

return nil


  static FUNCTION TListPropEx_EditCol( uVar, nItem, cPicture, bValid, nClrFore, nClrBack, aItems,bAction ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx


   local oFont
   local uTemp
   local aDim, aPos
   local cType
   local nWidth, nHeight
   local nTop, nLeft, nBottom, nRight
   local oProp := ::aItems[nItem]

   uTemp   := uVar
   nTop    := (::nRowPos)*::nHLine+2
   nLeft   := ::aColSizes[1]+::aColsizes[2]+1
   nBottom := nTop + ::nHLine-5
   nRight  := nLeft + ::aColSizes[3]
   aDim    := { nTop, nLeft, nBottom, nRight }

   cType   := ValType( uVar )

   If( bValid == nil, bValid := {|| .T. }, ) ;

   if ::oGet <> nil .AND. ! Empty( ::oGet:hWnd )
      ::oGet:End()
   endif

   if ::oFont <> nil
      oFont = TFont():New( ::oFont:cFaceName, ::oFont:nInpWidth, ::oFont:nInpHeight, .F., ::oFont:lBold )
   endif

   if cType == "C"
      uVar := padr( uVar, 255 )
   endif






   ::oGet := TGet():New( nTop +1, nLeft -1, { | u | If( PCount()==0, uVar, uVar:= u ) }, Self, nRight-nLeft, nBottom-nTop,,, ::nClrText, ::nClrPane, oFont, .F.,, .T.,, .F.,, .F., .F.,, .F., .F., .T.,,,,,,,,, "uVar", )
   if !empty( cPicture )
      ::oGet:oGet:Picture = cPicture
   endif

   ::nLastKey := 0
   ::oGet:SetFocus()

   if Upper( ::oGet:ClassName() ) <> "TGET"
      ::oGet:Refresh()
   endif







   ::oGet:bLostFocus := {|| ( ::oGet:Assign(), ::oGet:VarPut( if( valtype(::oGet:oGet:VarGet()) == "C", alltrim(::oGet:oGet:VarGet()), ::oGet:oGet:VarGet())), OSend( ::oObject, "_" + oProp:cProperty, ::oGet:oGet:VarGet())) , If( Self:nLastKey <> 27, Eval( bValid, uVar, Self:nLastKey, Self ), Eval( bValid, nil, Self:nLastKey, Self ) ), ::oGet:End(), ::oObject:Refresh() }


   ::oGet:bKeyDown := { | nKey | If( nKey == 13 .OR. nKey == 27, ( Self:nLastKey := nKey, ::oGet:End()), ) }
return uVar


  static FUNCTION TListPropEx_SetInspect( oObject ) ; local Self AS CLASS TListPropEx := QSelf() AS CLASS TListPropEx

local n, nItem, nLen

asize(::aItems, 0 )

::nItem   := 0
::nGrupos := 0

::oObject := oObject

::oObject:SetProps( self )

::GoTop()
::Refresh()

return nil





_HB_CLASS TWBrowse2 ; function TWBrowse2 ( ... ) ; static s_oClass ; local nScope, oClass, oInstance ; if s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; begin sequence ; nScope := 1 ; ( ( nScope ) ) ; oClass := IIF(.F.,, HBClass():new( "TWBrowse2" , iif( .T., { @TControl() }, { @HBObject() } ), @TWBrowse2() ) ) ;

 ; ; ;; _HB_MEMBER { cAlias, cField, uValue1, uValue2 } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cAlias", "cField", "uValue1", "uValue2"}, .F. )
 ; ; ; ; ; ;; _HB_MEMBER { bLine, bSkip, bGoTop, bGoBottom, bLogicLen, bChange, bAdd } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bLine", "bSkip", "bGoTop", "bGoBottom", "bLogicLen", "bChange", "bAdd"}, .F. )
 ; ; ; ;; _HB_MEMBER { nRowPos, nColPos, nLen, nAt, nColAct } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRowPos", "nColPos", "nLen", "nAt", "nColAct"}, .F. )
; _HB_MEMBER { nMaxFilter } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMaxFilter"}, .F. )

 ; ; ;; _HB_MEMBER { lHitTop, lHitBottom, lCaptured, lMChange } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lHitTop", "lHitBottom", "lCaptured", "lMChange"}, .F. )
 ;; _HB_MEMBER { lAutoEdit, lAutoSkip } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAutoEdit", "lAutoSkip"}, .F. )
; _HB_MEMBER { AS LOGICAL lCellStyle } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCellStyle"}, .F. )
 ;; _HB_MEMBER { aHeaders, aColSizes } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aHeaders", "aColSizes"}, .F. )
 ;; _HB_MEMBER { nClrBackHead, nClrForeHead } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrBackHead", "nClrForeHead"}, .F. )
 ;; _HB_MEMBER { nClrBackFocus, nClrForeFocus } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrBackFocus", "nClrForeFocus"}, .F. )
 ;; _HB_MEMBER { aJustify, aActions } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aJustify", "aActions"}, .F. )
; _HB_MEMBER { oGet } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oGet"}, .F. )
; _HB_MEMBER { nLineStyle } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLineStyle"}, .F. )
 ; ; ;; _HB_MEMBER { lIconView, aIcons, bIconDraw, bIconText } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lIconView", "aIcons", "bIconDraw", "bIconText"}, .F. )
 ;; _HB_MEMBER { nIconPos, nVScrollPos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nIconPos", "nVScrollPos"}, .F. )
; _HB_MEMBER { nHLine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHLine"}, .F. )

   _HB_MEMBER { AS LOGICAL lRegistered } ; oClass:AddMultiClsData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRegistered"}, .F. )





   _HB_MEMBER New( nRow, nCol, nWidth, nHeigth, bLine, aHeaders,  aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nForeBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions) AS CLASS TWBrowse2; oClass:AddMethod( "New", @TWBrowse2_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER ReDefine( nId, bLine, oDlg, aHeaders, aColSizes, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, bWhen, bValid, bLClick, aActions) AS CLASS TWBrowse2; oClass:AddMethod( "ReDefine", @TWBrowse2_ReDefine(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER nAtCol( nCol); oClass:AddMethod( "nAtCol", @TWBrowse2_nAtCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER nAtIcon( nRow, nCol); oClass:AddMethod( "nAtIcon", @TWBrowse2_nAtIcon(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER lCloseArea(); oClass:AddInline( "lCloseArea", {|Self | ( ( Self ) ), If( ! Empty( ::cAlias ), ( ::cAlias )->( DbCloseArea() ),), If( ! Empty( ::cAlias ), ::cAlias := "",), .T. }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER LDblClick( nRow, nCol, nKeyFlags); oClass:AddMethod( "LDblClick", @TWBrowse2_LDblClick(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Default(); oClass:AddMethod( "Default", @TWBrowse2_Default(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER BugUp(); oClass:AddInline( "BugUp", {|Self | ( ( Self ) ), ::UpStable() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Display(); oClass:AddMethod( "Display", @TWBrowse2_Display(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DrawIcons(); oClass:AddMethod( "DrawIcons", @TWBrowse2_DrawIcons(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )







   _HB_MEMBER DrawLine(); oClass:AddInline( "DrawLine", {|Self, nRow | ( ( Self ) ), ::wBrwLine( ::hWnd, ::hDC, If( nRow == nil, ::nRowPos, nRow ),  Eval( ::bLine, Self ), ::GetColSizes(), ::nColPos, ::nClrText, ::nClrPane, If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify, nil, ::nLineStyle,,, ::oVScroll, ::bLogicLen  ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DrawSelect(); oClass:AddMethod( "DrawSelect", @TWBrowse2_DrawSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER lEditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction); oClass:AddMethod( "lEditCol", @TWBrowse2_lEditCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Edit( nCol, lModal); oClass:AddMethod( "Edit", @TWBrowse2_Edit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER EditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction); oClass:AddMethod( "EditCol", @TWBrowse2_EditCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER EraseBkGnd(); oClass:AddInline( "EraseBkGnd", {|Self, hDC | ( ( Self ) ), 1 }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER GetColSizes(); oClass:AddInline( "GetColSizes", {|Self | ( ( Self ) ), If( ValType( ::aColSizes ) == "A", ::aColSizes, Eval( ::aColSizes, Self ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GetDlgCode( nLastKey); oClass:AddMethod( "GetDlgCode", @TWBrowse2_GetDlgCode(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GoUp(); oClass:AddMethod( "GoUp", @TWBrowse2_GoUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoDown(); oClass:AddMethod( "GoDown", @TWBrowse2_GoDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoLeft(); oClass:AddMethod( "GoLeft", @TWBrowse2_GoLeft(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoRight(); oClass:AddMethod( "GoRight", @TWBrowse2_GoRight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoTop(); oClass:AddMethod( "GoTop", @TWBrowse2_GoTop(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoBottom(); oClass:AddMethod( "GoBottom", @TWBrowse2_GoBottom(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER GotFocus(); oClass:AddInline( "GotFocus", {|Self | ( ( Self ) ), ::TControl:GotFocus(), If( ::nLen > 0 .AND. ! Empty( ::cAlias ) .AND.  ! ::lIconView, ::DrawSelect(),) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER HScroll( nWParam, nLParam); oClass:AddMethod( "HScroll", @TWBrowse2_HScroll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DrawIcon(); oClass:AddMethod( "DrawIcon", @TWBrowse2__DrawIcon(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Initiate(); oClass:AddInline( "Initiate", {|Self, hDlg | ( ( Self ) ), ::TControl:Initiate( hDlg ), ::Default() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER IsColVisible( nCol); oClass:AddMethod( "IsColVisible", @TWBrowse2_IsColVisible(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER KeyDown( nKey, nFlags); oClass:AddMethod( "KeyDown", @TWBrowse2_KeyDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER KeyChar( nKey, nFlags); oClass:AddMethod( "KeyChar", @TWBrowse2_KeyChar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LButtonDown( nRow, nCol, nKeyFlags); oClass:AddMethod( "LButtonDown", @TWBrowse2_LButtonDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LButtonUp( nRow, nCol, nKeyFlags); oClass:AddMethod( "LButtonUp", @TWBrowse2_LButtonUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER LostFocus(); oClass:AddInline( "LostFocus", {|Self, hCtlFocus | ( ( Self ) ), ::TControl:LostFocus( hCtlFocus ), If( ::nLen > 0 .AND. ! Empty( ::cAlias ) .AND.  ! ::lIconView, ::DrawSelect(),) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER MouseMove( nRow, nCol, nKeyFlags); oClass:AddMethod( "MouseMove", @TWBrowse2_MouseMove(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseWheel( nKeys, nDelta, nXPos, nYPos); oClass:AddMethod( "MouseWheel", @TWBrowse2_MouseWheel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PageUp( nLines); oClass:AddMethod( "PageUp", @TWBrowse2_PageUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PageDown( nLines); oClass:AddMethod( "PageDown", @TWBrowse2_PageDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Paint(); oClass:AddMethod( "Paint", @TWBrowse2_Paint(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RecAdd(); oClass:AddInline( "RecAdd", {|Self | ( ( Self ) ), If( ::bAdd <> nil, Eval( ::bAdd, Self ),) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RecCount(); oClass:AddMethod( "RecCount", @TWBrowse2__RecCount(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Report( cTitle, lPreview); oClass:AddMethod( "Report", @TWBrowse2_Report(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ReSize( nSizeType, nWidth, nHeight); oClass:AddMethod( "ReSize", @TWBrowse2_ReSize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER nRowCount(); oClass:AddInline( "nRowCount", {|Self | ( ( Self ) ), aClient := GetClientRect(::hWnd), int( ( aClient[3]-aClient[1]) / ::nHLine )-1 }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetArray( aArray); oClass:AddMethod( "SetArray", @TWBrowse2_SetArray(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetCols( aData, aHeaders, aColSizes); oClass:AddMethod( "SetCols", @TWBrowse2_SetCols(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetFilter( cField, uVal1, uVal2); oClass:AddMethod( "SetFilter", @TWBrowse2_SetFilter(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetTree( oTree); oClass:AddMethod( "SetTree", @TWBrowse2_SetTree(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ShowSizes(); oClass:AddMethod( "ShowSizes", @TWBrowse2_ShowSizes(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Skip( n); oClass:AddMethod( "Skip", @TWBrowse2_Skip(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER UpStable(); oClass:AddMethod( "UpStable", @TWBrowse2_UpStable(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VertLine( nColPos, nColInit); oClass:AddMethod( "VertLine", @TWBrowse2_VertLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VScroll( nWParam, nLParam); oClass:AddMethod( "VScroll", @TWBrowse2_VScroll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER VSetPos(); oClass:AddInline( "VSetPos", {|Self, nPos | ( ( Self ) ), ::nVScrollPos := nPos, ::oVScroll:SetPos( iif( ::nLen <= 10000, nPos, Int( nPos * 10000 / ::nLen ) ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER VThumbPos(); oClass:AddInline( "VThumbPos", {|Self, nPos | ( ( Self ) ), ::nVScrollPos := ::VGetThumbPos( nPos ), ::oVScroll:SetPos( nPos ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VGetPos(); oClass:AddInline( "VGetPos", {|Self | ( ( Self ) ), ::nVScrollPos }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER VSetRange(); oClass:AddInline( "VSetRange", {|Self | ( ( Self ) ), ::nVScrollPos := 1, ::oVScroll:SetRange( Min( 1, ::nLen ), Min( 10000, ::nLen ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER VGetMax(); oClass:AddInline( "VGetMax", {|Self | ( ( Self ) ), ::oVScroll:nMax * iif( ::nLen <= 10000, 1, ::nLen / 10000 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VGoDown(); oClass:AddInline( "VGoDown", {|Self | ( ( Self ) ), ::VSetPos( ::nVScrollPos + 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VGoUp(); oClass:AddInline( "VGoUp", {|Self | ( ( Self ) ), ::VSetPos( ::nVScrollPos - 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER VGetThumbPos(); oClass:AddInline( "VGetThumbPos", {|Self, nPos | ( ( Self ) ), iif( ::nLen <= 10000, nPos, Int( nPos * ::nLen / 10000 ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER VGoBottom(); oClass:AddInline( "VGoBottom", {|Self | ( ( Self ) ), ::VSetPos( ::nLen ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER VGoTop(); oClass:AddInline( "VGoTop", {|Self | ( ( Self ) ), ::VSetPos( 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




    _HB_MEMBER wBrwLine( hWnd, hDC, nRowPos, aValues, aColSizes, nColPos, nClrText, nClrPane, hFont, lTree, aJustify, nPressed, nLineStyle, nColAct, lFocused, oVScroll, bLogicLen, lBar); oClass:AddMethod( "wBrwLine", @TWBrowse2_wBrwLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; oInstance := oClass:Instance() ; if __ObjHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; end ; always ; __clsUnlockDef( @s_oClass, oClass ) ; end ; return oInstance ; end ; return s_oClass:Instance() AS CLASS TWBrowse2 ;






static FUNCTION TWBrowse2_New( nRow, nCol, nWidth, nHeigth, bLine, aHeaders, aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2









   If( nRow == nil, nRow := 0, ) ; If( nCol == nil, nCol := 0, ); If( nHeigth == nil, nHeigth := 100, ); If( nWidth == nil, nWidth := 100, ); If( oWnd == nil, oWnd := GetWndDefault(), ); If( oFont == nil, oFont := oWnd:oFont, ); If( nClrFore == nil, nClrFore := 0, ); If( nClrBack == nil, nClrBack := GetSysColor( 5 ), ); If( lUpdate == nil, lUpdate := .F., ); If( cAlias == nil, cAlias := Alias(), ); If( lPixel == nil, lPixel := .F., ); If( lDesign == nil, lDesign := .F., ); If( bValid == nil, bValid := {||.T.}, );




   ::aProperties := {"nTop","nLeft","nBottom","nRight","nClrPane","nClrText","nColPos","nId","lAutoEdit","nHLine","lCellStyle","cAlias"}
   ::cCaption   = ""
   ::nTop       = nRow * If( lPixel, 1, 14 )
   ::nLeft      = nCol * If( lPixel, 1, 8 )
   ::nBottom    = ::nTop + nHeigth - 1
   ::nRight     = ::nLeft + nWidth - 1
   ::oWnd       = oWnd
   ::lHitTop    = .F.
   ::lHitBottom = .F.
   ::lFocused   = .F.
   ::lCaptured  = .F.
   ::lMChange   = .T.
   ::nRowPos    = 1
   ::nColPos    = 1
   ::nColAct    = 1


   ::nStyle     = nOr( 1073741824, 2097152, 1048576, 8388608, 268435456, 65536, If( lDesign, 67108864, 0 ) )
   ::nId        = ::GetNewId()
   ::cAlias     = cAlias
   ::bLine      = bLine
   ::lAutoEdit  = .F.
   ::lAutoSkip  = .F.
   ::lIconView  = .F.
   ::lCellStyle = .F.
   ::nIconPos   = 0
   ::nHLine     := 20
   ::SetFilter( cField, uVal1, uVal2 )

   ::bAdd       = { || ( ::cAlias )->( DbAppend() ), ::UpStable() }

   ::aHeaders   = aHeaders
   ::aColSizes  = aColSizes
   ::nLen       = 0
   ::lDrag      = lDesign
   ::lCaptured  = .F.
   ::lMChange   = .T.
   ::bChange    = bChange
   ::bLClicked  = bLClick
   ::bLDblClick = bLDblClick
   ::bRClicked  = bRClick

   ::oCursor    = oCursor


   ::nLineStyle    := 2
   ::nClrBackHead  := GetSysColor( 15 )
   ::nClrForeHead  := GetSysColor( 18 )
   ::nClrBackFocus := GetSysColor( 13 )
   ::nClrForeFocus := 16777215

   ::cMsg          = cMsg
   ::lUpdate       = lUpdate
   ::bWhen         = bWhen
   ::bValid        = bValid
   ::aActions      = aActions
   ::nVScrollPos   = 0

   ::SetColor( nClrFore, nClrBack )





   ::Register( nOr( 1, 2, 8 ) )

   if ! Empty( oWnd:hWnd )
      ::Create()
      if oFont <> nil
         ::SetFont( oFont )
      endif
      ::Default()
      ::lVisible = .T.
      oWnd:AddControl( Self )
   else
      ::oFont := oFont
      oWnd:DefControl( Self )
      ::lVisible = .F.
   endif

   if lDesign
      ::CheckDots()
   endif

return Self






static FUNCTION TWBrowse2_ReDefine( nId, bLine, oDlg, aHeaders, aColSizes, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, bWhen, bValid, bLClick, aActions ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2


   If( oDlg == nil, oDlg := GetWndDefault(), ) ; If( nClrFore == nil, nClrFore := 0, ); If( nClrBack == nil, nClrBack := GetSysColor( 5 ), ); If( lUpdate == nil, lUpdate := .F., ); If( cAlias == nil, cAlias := Alias(), );

   ::lHitTop    = .F.
   ::lHitBottom = .F.
   ::lFocused   = .F.
   ::nId        = nId
   ::nRowPos    = 1
   ::nColPos    = 1
   ::nColAct    = 1
   ::cAlias     = cAlias
   ::oWnd       = oDlg
   ::aHeaders   = aHeaders
   ::aColSizes  = aColSizes
   ::nClrPane   = 12632256
   ::nClrText   = 16777215
   ::nLen       = 0
   ::lDrag      = .F.
   ::lCaptured  = .F.
   ::lVisible   = .F.
   ::lCaptured  = .F.
   ::lMChange   = .T.

   ::bLine      = bLine
   ::bChange    = bChange
   ::bLClicked  = bLClick
   ::bLDblClick = bLDblClick
   ::bRClicked  = bRClick

   ::oCursor    = oCursor
   ::oFont      = oFont

   ::nLineStyle    := 2

   ::nClrBackHead  := GetSysColor( 15 )
   ::nClrForeHead  := 0
   ::nClrBackFocus := GetSysColor( 13 )
   ::nClrForeFocus := 16777215

   ::cMsg          = cMsg
   ::lUpdate       = lUpdate
   ::bWhen         = bWhen
   ::bValid        = bValid
   ::aActions      = aActions
   ::lAutoEdit     = .F.
   ::lAutoSkip     = .F.
   ::lIconView     = .F.
   ::lCellStyle    = .F.
   ::nIconPos      = 0
   ::nVScrollPos   = 0

   ::SetColor( nClrFore, nClrBack )

   ::SetFilter( cField, uVal1, uVal2 )
   ::bAdd       = { || ( ::cAlias )->( DbAppend() ), ::UpStable() }

   ::Register( nOr( 1, 2, 8 ) )

   oDlg:DefControl( Self )

return Self





static FUNCTION TWBrowse2_DrawSelect( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   if ::lCellStyle
      ::DrawLine()





      ::wBrwLine( ::hWnd, ::hDC, ::nRowPos, Eval( ::bLine, Self ), ::GetColSizes(), ::nColPos, ::nClrForeFocus, If( ::lFocused, ::nClrBackFocus, 8421504 ), If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify,, ::nLineStyle, ::nColAct, ::lFocused, ::oVScroll, ::bLogicLen )
   else





      ::wBrwLine( ::hWnd, ::hDC, ::nRowPos, Eval( ::bLine, Self ), ::GetColSizes(), ::nColPos, ::nClrForeFocus, If( ::lFocused, ::nClrBackFocus, 8421504 ), If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify,, ::nLineStyle, nil, ::lFocused, ::oVScroll, ::bLogicLen, .T. )
   endif

return nil



static FUNCTION TWBrowse2_DrawIcons( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nWidth := ::nWidth(), nHeight := ::nHeight()
   local nRow := 10, nCol := 10
   local n := 1, nIcons := Int( nWidth / 50 ) * Int( nHeight / 50 )
   local hIcon := ExtractIcon( "user.exe", 0 )
   local oFont, cText

   oFont := TFont():New( GetSysFont(), 0, -8,,,,,,, .T.,,,,,,, )

   SelectObject( ::hDC, oFont:hFont )
   SetBkColor( ::hDC, 8388608 )
   SetTextColor( ::hDC, 16777215 )

   while n <= nIcons .AND. ! ( ::cAlias )->( EoF() )
      if ::bIconDraw <> nil .AND. ::aIcons <> nil
         hIcon = ::aIcons[ Eval( ::bIconDraw, Self ) ]
      endif
      DrawIcon( ::hDC, nRow, nCol, hIcon )
      if ::bIconText <> nil
         cText = cValToChar( Eval( ::bIconText, Self ) )
      else
         cText = Str( ( ::cAlias )->( RecNo() ) )
      endif

      DrawText( ::hDC, cText, { nRow + 35, nCol - 5, nRow + 48, nCol + 40 }, 1 )
      nCol += 50
      if nCol >= nWidth - 32
         nRow += 50
         nCol  = 10
      endif
      ( ::cAlias )->( DbSkip() )
      n++
   end
   ( ::cAlias )->( DbSkip( 1 - n ) )

   oFont:End()

return nil



static FUNCTION TWBrowse2_Edit( nCol, lModal ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local uTemp, cType, lAutoSave, lContinue

   If( nCol == nil, nCol := 1, ) ; If( lModal == nil, lModal := .T., );

   while .T.
      uTemp = Eval( ::bLine, Self )[ nCol ]
      if ! Empty( ::cAlias ) .AND. Upper( ::cAlias ) <> "ARRAY"
         lAutoSave = ( cValToChar( ( ::cAlias )->( FieldGet( nCol ) ) ) == uTemp )
         if ( ::cAlias )->( RLock() )
            if lContinue := ::lEditCol( nCol, @uTemp )
               if lAutoSave
                  cType = ValType( ( ::cAlias )->( FieldGet( nCol ) ) )
                  do case
                     case cType == "D"
                        ( ::cAlias )->( FieldPut( nCol, CToD( uTemp ) ) )

                     case cType == "L"
                        ( ::cAlias )->( FieldPut( nCol, Upper( uTemp ) == ".T." ) )

                     case cType == "N"
                        ( ::cAlias )->( FieldPut( nCol, Val( uTemp ) ) )

                     otherwise
                        ( ::cAlias )->( FieldPut( nCol, uTemp ) )
                  endcase
               endif
               ::DrawSelect()
            endif
            ( ::cAlias )->( DbUnLock() )
         else
            MsgStop( "Record locked!", "Please, try again" )
         endif
      else
         ::lEditCol( nCol, @uTemp )
      endif
      if lContinue .AND. ::lAutoSkip
         if nCol < Len( Eval( ::bLine, Self ) )
            ::GoRight()
            nCol++
         else
            ::nColPos = 1
            nCol = 1
            ::GoDown()
         endif
      endif
   if ! ( ::lAutoSkip .AND. lContinue ); exit; end; end

return nil




static FUNCTION TWBrowse2_EditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local oFont
   local uTemp
   local aDim, aPos
   local cType
   local nWidth, nHeight

   If( nCol == nil, nCol := ::nColAct, ) ;

   uTemp   := uVar

   aDim    := aBrwPosRect( ::hWnd, ::nRowPos, ::aColSizes, ::nColPos, nCol, If( ::oFont <> nil, ::oFont:hFont, 0 ) )
   aPos    := { aDim[ 1 ], aDim[ 2 ] }
   cType   := ValType( uVar )

   nWidth  := aDim[ 4 ] - aDim[ 2 ]
   nWidth  := ::aColSizes[nCol]
   nHeight := aDim[ 3 ] - aDim[ 1 ]

   ScreenToClient( Self:hWnd, aPos )

   IF ::lCellStyle .AND. nCol <> ::nColAct
        ::nColAct := nCol
         if ::oHScroll <> nil
            ::oHScroll:SetPos(nCol)
         endif
        ::Refresh(.F.)
   ENDIF



   If( nClrFore == nil, nClrFore := ::nClrText, ) ; If( nClrBack == nil, nClrBack := ::nClrPane, ); If( bValid == nil, bValid := {|| .T. }, );

   if ::oGet <> nil .AND. ! Empty( ::oGet:hWnd )
      ::oGet:End()
   endif

   if ::oFont <> nil

      oFont = TFont():New( ::oFont:cFaceName, ::oFont:nInpWidth, ::oFont:nInpHeight, .F., ::oFont:lBold )
   endif

   do case
      case cType == "L"
           If( aItems == nil, aItems := { ".T.", ".F." }, ) ;
           uVar = If( uTemp, aItems[ 1 ], aItems[ 2 ] )




           ::oGet := TComboBox():New( aPos[ 1 ] + 1, aPos[ 2 ] + 1, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, Min(100,Max(nWidth,50)), 100, Self,, {|Self|::End()},, nClrFore, nClrBack, .T., oFont,, .F.,, .F.,,,,, )

      case aItems <> nil




           ::oGet := TComboBox():New( aPos[ 1 ] + 1, aPos[ 2 ] + 1, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, nWidth, Max( 200, Len( aItems ) * 25 ), Self,, {|Self|::End()},, nClrFore, nClrBack, .T., oFont,, .F.,, .F.,,,,, )

      otherwise




          ::oGet := TGet():New( aPos[ 1 ] + 1, aPos[ 2 ] + 1, { | u | If( PCount()==0, uVar, uVar:= u ) }, Self, nWidth, nHeight,,, nClrFore, nClrBack, oFont, .F.,, .T.,, .F.,, .F., .F.,, .F., .F., .F.,, .F.,,,,,,, "uVar", )

          ::oGet:oGet:Picture = cPicture
   endcase

   ::nLastKey := 0

      ::oGet:Set3dLook()

   ::oGet:SetFocus()

   if Upper( ::oGet:ClassName() ) <> "TGET"
      ::oGet:Refresh()
   endif







   ::oGet:bLostFocus := {|| If( Upper( ::oGet:ClassName() ) == "TGET", ( ::oGet:Assign(), ::oGet:VarPut( ::oGet:oGet:VarGet())), ::oGet:VarPut( If( cType == "L", ( uVar == aItems[ 1 ] ), ::oGet:VarGet() ) ) ), If( Self:nLastKey <> 27, Eval( bValid, uVar, Self:nLastKey, Self ), Eval( bValid, nil, Self:nLastKey, Self ) ), ::oGet:End() }



   ::oGet:bKeyDown := { | nKey | If( nKey == 13 .OR.  nKey == 27, ( Self:nLastKey := nKey, ::oGet:End()), ) }
return .F.



static FUNCTION TWBrowse2_ReSize( nSizeType, nWidth, nHeight ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   ::nRowPos = Min( ::nRowPos, Max( ::nRowCount(), 1 ) )

return ::TControl:ReSize( nSizeType, nWidth, nHeight )



static FUNCTION TWBrowse2_SetArray( aArray ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   ::nAt       = 1
   ::cAlias    = "ARRAY"

   ::bLogicLen = { || ::nLen := Len( aArray ) }
   ::bGoTop    = { || ::nAt := 1 }
   ::bGoBottom = { || ::nAt := Eval( ::bLogicLen, Self ) }


   ::bSkip     = { | nSkip, nOld | nOld := ::nAt, ::nAt += nSkip, ::nAt := Min( Max( ::nAt, 1 ), Eval( ::bLogicLen, Self ) ), ::nAt - nOld }
return nil



static FUNCTION TWBrowse2_SetTree( oTree ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local oItem := oTree:oFirst

   ::lMChange   = .F.
   ::bLine      = { || oItem:GetLabel() }
   ::aColSizes  = { || oItem:ColSizes() }
   ::bGoTop     = { || oItem := oTree:oFirst }
   ::bGoBottom  = { || oItem := oTree:GetLast() }
   ::bSkip      = { | n | oItem := oItem:Skip( @n ), ::Cargo := oItem, n }
   ::bLogicLen  = { || ::nLen := oTree:nCount() }

   ::bLDblClick = { || If( oItem:oTree <> nil, ( oItem:Toggle(), ::Refresh() ),) }
   ::Cargo      = oItem

   ::bKeyChar   = { | nKey | If( nKey == 13 .AND. oItem:oTree <> nil, ( oItem:Toggle(), ::Refresh() ),) }

   if ::oHScroll <> nil
      ::oHScroll:SetRange( 0, 0 )
      ::oHScroll = nil
   endif

   oTree:Draw()

return nil



static FUNCTION TWBrowse2_Paint( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local n := 1, nSkipped := 1, nLines


   FillRect( ::hDC, GetClientRect( ::hWnd ), ::oBrush:hBrush )

   if ::lIconView
      ::DrawIcons()
      return 0
   endif


   if ::nRowPos == 1 .AND. ! Empty( ::cAlias ) .AND.  Upper( ::cAlias ) <> "ARRAY"
      if ! ( ::cAlias )->( EoF() )
         ( ::cAlias )->( DbSkip( -1 ) )
         if ! ( ::cAlias )->( BoF() )
            ( ::cAlias )->( DbSkip() )
         endif
      endif
   endif




   ::wBrwLine( ::hWnd, ::hDC, 0, ::aHeaders, ::GetColSizes(), ::nColPos, ::nClrForeHead, ::nClrBackHead, If( ::oFont <> nil, ::oFont:hFont, 0 ),.F., ::aJustify, nil, ::nLineStyle,,, ::oVScroll, ::bLogicLen )

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) > 0

      ::Skip( 1 - ::nRowPos )


         nLines = ::nRowCount()
         while n <= nLines .AND. nSkipped == 1
            ::DrawLine( n )
            nSkipped = ::Skip( 1 )
            if nSkipped == 1
               n++
            endif
         end
         ::Skip( ::nRowPos - n )









      if ::nLen < ::nRowPos
         ::nRowPos = ::nLen
      endif

      ::DrawSelect()
   endif

   if ! Empty( ::cAlias ) .AND. Upper( ::cAlias ) <> "ARRAY"
      ::lHitTop    = ( ::cAlias )->( BoF() )
      ::lHitBottom = ( ::cAlias )->( EoF() )
   endif



return 0




static FUNCTION TWBrowse2_lEditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local oDlg, oGet, oFont, oBtn, oBtnAction
   local nWidth := ::aColSizes[ nCol ]
   local uTemp
   local aDim
   local lOk
   local cType



   If( nClrFore == nil, nClrFore := ::nClrText, ) ; If( nClrBack == nil, nClrBack := ::nClrPane, ); If( nCol == nil, nCol := ::nColAct, );

   uTemp  := uVar

   aDim   := aBrwPosRect( ::hWnd, ::nRowPos, ::aColSizes, ::nColPos, nCol, If( ::oFont <> nil, ::oFont:hFont, 0 ) )
   aDim[ 1 ] = aDim[ 1 ] + 1
   lOk    := .F.
   cType  := ValType( uVar )

   IF ::lCellStyle .AND. nCol <> ::nColAct
        ::nColAct := nCol
         if ::oHScroll <> nil
            ::oHScroll:SetPos(nCol)
         endif
        ::Refresh(.F.)
   ENDIF


   oDlg = TDialog():New( aDim[ 1 ], aDim[ 2 ], aDim[ 3 ], aDim[ 4 ],,,, .F., nOR( 268435456, 2147483648 ),,,,, .T.,,,,,, .F., )

   if ::oFont <> nil

      oFont = TFont():New( ::oFont:cFaceName, ::oFont:nInpWidth, ::oFont:nInpHeight, .F., ::oFont:lBold )
   endif




   do case
      case cType == "L"
           If( aItems == nil, aItems := { ".T.", ".F." }, ) ;
           uVar = If( uTemp, aItems[ 1 ], aItems[ 2 ] )



           oGet := TComboBox():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, ( aDim[ 4 ] - aDim[ 2 ] ) * 0.50, 50, oDlg,, {|Self|( oDlg:End(), lOk := .T. )},, nClrFore, nClrBack, .F., oFont,, .F.,, .F.,,,,, )

      case aItems <> nil



           oGet := TComboBox():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, ( aDim[ 4 ] - aDim[ 2 ] ) * 0.50, 50, oDlg,, {|Self|( oDlg:End(), lOk := .T. )},, nClrFore, nClrBack, .F., oFont,, .F.,, .F.,,,,, )

      otherwise



         oGet := TGet():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, oDlg, aDim[ 4 ] - aDim[ 2 ] - If( bAction <> nil, 12, 0 ), aDim[ 3 ] - aDim[ 1 ],,, nClrFore, nClrBack, oFont, .F.,, .F.,, .F.,, .F., .F.,, .F., .F., .F.,, .F.,,,,,,, "uVar", )

         oGet:oGet:Picture = cPicture

         if bAction <> nil
            oBtnAction := TButton():New( 0, 0, "", oDlg,, 12, 12,,, .F., .F., .F.,, .F.,,, .F. )

            oBtnAction:bAction = { || oGet:VarPut( Eval( bAction, uVar, Self ) ), oDlg:End(), lOk := .T.  }
         endif
   endcase

   oGet:bValid = bValid

   oBtn := TButton():New( 10, 0, "", oDlg, {|| ( oDlg:End(), lOk := .T. )},,,,, .T., .F., .F.,, .F.,,, .F. )


   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F.,,, {|Self|DlgAdjust( oDlg, oGet, oBtnAction, aDim, cType )}, oDlg:bRClicked,,, )

   if ! lOk
      uVar = uTemp
   else
      if cType == "L"
         uVar = ( uVar == aItems[ 1 ] )
      endif
   endif

return lOk



static function DlgAdjust( oDlg, oGet, oBtnAction, aDim, cType )


   oDlg:Move( aDim[ 1 ] + 1, aDim[ 2 ] + 1, aDim[ 4 ] - aDim[ 2 ], aDim[ 3 ] - aDim[ 1 ] )

   do case
      case cType == "L"
           oGet:Move( -3, -1, aDim[ 4 ] - aDim[ 2 ] + 3, 50 )

      case oBtnAction <> nil

           oGet:Move( -3, -1, aDim[ 4 ] - aDim[ 2 ] - 14, aDim[ 3 ] - aDim[ 1 ] + 6 )

           oBtnAction:Move( 0, aDim[ 4 ] - aDim[ 2 ] - 15, 15, aDim[ 3 ] - aDim[ 1 ] )

    otherwise
           oGet:Move( -2, 0 )
   endcase

return nil



static FUNCTION TWBrowse2_GoUp( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nLines := ::nRowCount()

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitTop
      ::DrawLine()
      if ::Skip( -1 ) == -1
         ::lHitBottom = .F.
         if ::nRowPos > 1
            ::nRowPos--
         else
            WBrwScroll( ::hWnd, -1, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::nHLine )
         endif
      else
         ::lHitTop = .T.
      endif
      ::DrawSelect()
      if ::oVScroll <> nil
         ::VGoUp()
      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   endif

return nil



static FUNCTION TWBrowse2_GoDown( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nLines := ::nRowCount()

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitBottom
      ::DrawLine()
      if ::Skip( 1 ) == 1
         ::lHitTop = .F.
         if ::nRowPos < nLines
            ::nRowPos++
         else
            WBrwScroll( ::hWnd, 1, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::nHLine )
         endif
      else
         ::lHitBottom = .T.
      endif
      ::DrawSelect()
      if ::oVScroll <> nil
         ::VGoDown()
      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   endif

return nil



static FUNCTION TWBrowse2_GoLeft( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   if ::nColAct > 1
      if ::lCellStyle .AND. ::IsColVisible( ::nColAct-1 )
         ::nColAct--
         ::DrawSelect()
      else
         ::nColPos--
         ::nColAct--
         ::Refresh()
      endif
      if ::oHScroll <> nil
         ::oHScroll:GoUp()
      endif
   endif

return nil



static FUNCTION TWBrowse2_GoRight( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local lColVisible

   if ::nColAct < Len( ::GetColSizes() )
      lColVisible = ::IsColVisible( ::nColAct + 1 )
      ::nColAct++
      while ! ::IsColVisible( ::nColAct ) .AND. ::nColPos < ::nColAct
         ::nColPos++
      enddo
      if ! ::lCellStyle
         ::nColPos := ::nColAct
         ::Refresh()
      else
         if lColVisible
            ::DrawSelect()
         else
            ::Refresh()
         endif
      endif
      if ::oHScroll <> nil
         ::oHScroll:GoDown()
      endif
   endif

return nil



static FUNCTION TWBrowse2_GoTop( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitTop
      Eval( ::bGoTop, Self )
      ::lHitTop = .T.
      ::lHitBottom = .F.
      ::nRowPos = 1
      ::Refresh( .F. )
      if ::oVScroll <> nil
         ::VGoTop()
      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   endif

return nil



static FUNCTION TWBrowse2_GoBottom( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nSkipped
   local nLines := ::nRowCount()
   local n

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitBottom
      ::lHitBottom = .T.
      ::lHitTop    = .F.

      Eval( ::bGoBottom, Self )

      nSkipped = ::Skip( -( nLines - 1 ) )
      ::nRowPos = 1 - nSkipped

      ::GetDC()
      for n = 1 to -nSkipped
          ::DrawLine( n )
          ::Skip( 1 )
      next
      ::DrawSelect()
      ::ReleaseDC()
      if ::oVScroll <> nil
         ::nLen = Eval( ::bLogicLen, Self )
         if ::VGetMax() <> ::nLen
            ::VSetRange()
         endif
         ::VGoBottom()
      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   endif

return nil



static FUNCTION TWBrowse2_LDblClick( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2


   local nClickRow := nWRow( ::hWnd, ::hDC, nRow, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::nHLine )
   local nBrwCol

   if nClickRow == ::nRowPos .AND. ::nLen > 0
      nBrwCol = ::nAtCol( nCol )
      if ::lAutoEdit
         ::Edit( nBrwCol )
      else
         return ::TControl:LDblClick( nRow, nCol, nKeyFlags )
      endif
   endif

return nil



static function nWRow( hWnd, hDC, nRow, oFont, nHLine )
local aRect := GetClientRect( hWnd )

nRow := int( nRow/nHLine)

return nRow

static FUNCTION TWBrowse2_LButtonDown( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nClickRow, nSkipped
   local nColPos := 0, nColInit := ::nColPos - 1
   local nAtCol

   if ::lDrag
      return ::TControl:LButtonDown( nRow, nCol, nKeyFlags )
   endif

   nClickRow = nWRow( ::hWnd, ::hDC, nRow, If( ::oFont <> nil, ::oFont:hFont, 0 ),::nHline )

   if ::nLen < 1 .AND. nClickRow <> 0
      return nil
   endif





   if ::lMChange .AND. AScan( ::GetColSizes(), { | nColumn | nColPos += nColumn, nColInit++, nCol >= nColPos - 1 .AND.  nCol <= nColPos + 1 }, ::nColPos ) <> 0
      if ! ::lCaptured
         ::lCaptured = .T.
         ::Capture()
         ::VertLine( nColPos, nColInit )
      endif
      return nil
   endif

   ::SetFocus()

   if nClickRow == 0 .AND. Valtype(nKeyFlags) == "N"

      if ::aActions <> nil .AND.  ( nAtCol := ::nAtCol( nCol ) ) <= Len( ::aActions )
            if ::aActions[ nAtCol ] <> nil



               ::wBrwLine( ::hWnd, ::GetDC(), 0, ::aHeaders, ::GetColSizes(), ::nColPos, ::nClrForeHead, ::nClrBackHead, If( ::oFont <> nil, ::oFont:hFont, 0 ),.F., ::aJustify, nAtCol, ::nLineStyle,,, ::oVScroll, ::bLogicLen )
               ::ReleaseDC()
               Eval( ::aActions[ nAtCol ], Self, nRow, nCol )



               ::wBrwLine( ::hWnd, ::GetDC(), 0, ::aHeaders, ::GetColSizes(), ::nColPos, ::nClrForeHead, ::nClrBackHead, If( ::oFont <> nil, ::oFont:hFont, 0 ),.F., ::aJustify,, ::nLineStyle,,, ::oVScroll, ::bLogicLen )
               ::ReleaseDC()
            else
               MsgBeep()
            endif
      else
         MsgBeep()
      endif
   endif


   if nClickRow > 0 .AND. nClickRow <> ::nRowPos .AND.  nClickRow < ::nRowCount() + 1
      ::DrawLine()
      nSkipped  = ::Skip( nClickRow - ::nRowPos )
      ::nRowPos += nSkipped
      if ::oVScroll <> nil
         ::VSetPos( ::VGetPos() + nSkipped )
      endif
      if ::lCellStyle
           ::nColAct := ::nAtCol( nCol )
           if ::oHScroll <> nil
              ::oHScroll:SetPos(::nColAct)
           endif
      endif
      ::DrawSelect()
      ::lHitTop = .F.
      ::lHitBottom = .F.
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   else
      if ::lCellStyle
           ::nColAct := ::nAtCol( nCol )
           if ::oHScroll <> nil
              ::oHScroll:SetPos(::nColAct)
           endif
           ::Refresh(.F.)
      endif
   endif

   ::TControl:LButtonDown( nRow, nCol, nKeyFlags )

return 0



static FUNCTION TWBrowse2_LButtonUp( nRow, nCol, nFlags ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   if ::lDrag
      return ::TControl:LButtonUp( nRow, nCol, nFlags )
   endif

   if ::lCaptured
      ::lCaptured = .F.
      ReleaseCapture()
      ::VertLine()
   endif

   ::TControl:LButtonUp( nRow, nCol, nFlags )

return nil



static FUNCTION TWBrowse2_Default( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local n, aFields
   local cAlias := Alias()
   local nElements, nTotal := 0

   If( ::aHeaders == nil, ::aHeaders := {}, ) ; If( ::aColSizes == nil, ::aColSizes := {}, );

   if ::bLine == nil
      if Empty( ::cAlias )
         ::cAlias = cAlias
      else
         cAlias = ::cAlias
      endif
      ::bLine  = { || _aFields( Self ) }
      if ::aJustify == nil
         ::aJustify = Array( nElements := Len( Eval( ::bLine, Self ) ) )
         for n = 1 to nElements
             ::aJustify[ n ] = ( ValType( ( cAlias )->( FieldGet( n ) ) ) == "N" )
         next
      endif
   endif

   If( nElements == nil, nElements := Len( Eval( ::bLine, Self ) ), ) ;

   if Len( ::aHeaders ) < nElements
      if ::Cargo == nil
         ::aHeaders = Array( nElements )
         for n = 1 to nElements
             ::aHeaders[ n ] = ( cAlias )->( FieldName( n ) )
         next
      else
         ::aHeaders = { "" }
      endif
   endif

   if Len( ::GetColSizes() ) < nElements
      ::aColSizes = Afill(Array( nElements ), 0 )
      aFields = Eval( ::bLine, Self )
      for n = 1 to nElements





          ::aColSizes[ n ] := If( ValType( aFields[ n ] ) <> "C", 15, GetTextWidth( 0, Replicate( "B",  Max( Len( ::aHeaders[ n ] ),  Len( aFields[ n ] ) ) + 1 ), If( ! Empty( ::oFont ), ::oFont:hFont,) ) )
      next
   endif


   if lAnd( GetWindowLong( ::hWnd, -16 ), 2097152 ) .OR.  GetClassName( ::hWnd ) == "ListBox"
      ::oVScroll := TScrollBar():WinNew(,,, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
      ::nLen := Eval( ::bLogicLen, Self )
      ::oVScroll:SetPage( Min( ::nRowCount(), ::nLen - 1 ) )
      ::VSetRange()
   endif

   if lAnd( GetWindowLong( ::hWnd, -16 ), 1048576 )
      if ::Cargo == nil

         ::oHScroll := TScrollBar():WinNew( 1, Len( ::GetColSizes() ),, (!.T.), Self,,,,,,,,, .F.,, )
         AEval( ::GetColSizes(), { | nSize | nTotal += nSize } )
         ::oHScroll:SetPage( nTotal / ::nWidth() )
      endif
   endif

   if ::uValue1 <> nil
      Eval( ::bGoTop, Self )
   endif
   if ::bChange <> nil
      Eval( ::bChange, Self )
   endif

return nil



static FUNCTION TWBrowse2_KeyDown( nKey, nFlags ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   do case
      case nKey == 38
           ::GoUp()

      case nKey == 40
           ::GoDown()

      case nKey == 37
           ::GoLeft()

      case nKey == 39
           ::GoRight()

      case nKey == 36
           ::GoTop()

      case nKey == 35
           ::GoBottom()

      case nKey == 33
           if GetKeyState( 17 )
              ::GoTop()
           else
              ::PageUp()
           endif

      case nKey == 34
           if GetKeyState( 17 )
              ::GoBottom()
           else
              ::PageDown()
           endif

      otherwise
           return ::TControl:KeyDown( nKey, nFlags )
   endcase

return 0



static FUNCTION TWBrowse2_KeyChar( nKey, nFlags ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   do case
      case nKey == 18
           ::oVScroll:PageUp()

      case nKey == 3
           ::oVScroll:PageDown()

      otherwise
           return ::TControl:KeyChar( nKey, nFlags )
   endcase

return 0



static FUNCTION TWBrowse2_PageUp( nLines ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nSkipped

   If( nLines == nil, nLines := ::nRowCount(), ) ;

   nSkipped = ::Skip( -nLines )

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitTop
      if nSkipped == 0
         ::lHitTop = .T.
      else
         ::lHitBottom = .F.
         if -nSkipped < nLines
            ::nRowPos = 1
            if ::oVScroll <> nil
               ::VSetPos( 1 )
            endif
         else

            nSkipped = ::Skip( -nLines )
            ::Skip( -nSkipped )

            if ::oVScroll <> nil
               ::VSetPos( ::VGetPos() + nSkipped )
            endif

         endif
         ::Refresh( .F. )
         if ::bChange <> nil
            Eval( ::bChange, Self )
         endif

      endif

   else
      if ::oVScroll <> nil
         ::VGoTop()
      endif
   endif

return nil



static FUNCTION TWBrowse2_PageDown( nLines ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nSkipped, n

   If( nLines == nil, nLines := ::nRowCount(), ) ;

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitBottom
      ::DrawLine()
      nSkipped = ::Skip( ( nLines * 2 ) - ::nRowPos )

      if nSkipped <> 0
         ::lHitTop = .F.
      endif

      do case
         case nSkipped == 0 .OR. nSkipped < nLines
              if nLines - ::nRowPos < nSkipped
                 ::GetDC()
                 ::Skip( -( nLines ) )
                 for n = 1 to ( nLines - 1 )
                     ::Skip( 1 )
                     ::DrawLine( n )
                 next
                 ::ReleaseDC()
                 ::Skip( 1 )
              endif
              ::nRowPos = Min( ::nRowPos + nSkipped, nLines )
              ::lHitBottom = .T.
              if ::oVScroll <> nil
                 ::VGoBottom()
              endif

         otherwise
              ::GetDC()
              for n = nLines to 1 step -1
                  ::DrawLine( n )
                  ::Skip( -1 )
              next
              ::ReleaseDC()
              ::Skip( ::nRowPos )
      endcase
      ::DrawSelect()
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif

      if ::oVScroll <> nil
         if ! ::lHitBottom
            ::VSetPos( ::VGetPos() + nSkipped - ( nLines - ::nRowPos ) )
         else
            ::VGoBottom()
         endif
      endif
   endif

return nil



static FUNCTION TWBrowse2_VScroll( nWParam, nLParam ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nLines := ::nRowCount()
   local nLen






      local nScrHandle  := nLParam
      local nScrollCode := nLoWord( nWParam )
      local nPos        := nHiWord( nWParam )


   if GetFocus() <> ::hWnd
      SetFocus( ::hWnd )
   endif

   if nScrHandle == 0
      if ::oVScroll <> nil
                  do case
                  case nScrollCode == 0
                          ::GoUp()

                  case nScrollCode == 1
                          ::GoDown()

                  case nScrollCode == 2
                          ::PageUp()

                  case nScrollCode == 3
                          ::PageDown()

                  case nScrollCode == 6
                          ::GoTop()

                  case nScrollCode == 7
                          ::GoBottom()

                  case nScrollCode == 4
               if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
                          return 0
                          endif

               if nPos <= 1
                          ::GoTop()
                          elseif nPos == ::oVScroll:GetRange()[ 2 ]
                          ::GoBottom()
                          else
                          CursorWait()
                  ::Skip( ::VGetThumbPos( nPos ) - ::VGetPos() )
                          ::lHitTop = .F.
                          ::lHitBottom = .F.
                          CursorArrow()
                          endif
               ::VThumbPos( nPos )

               nLen = Eval( ::bLogicLen, Self )
                          if nPos - ::oVScroll:nMin < nLines
                          ::nRowPos = 1
                          endif
                          if ::oVScroll:nMax - nPos < Min( nLines, nLen )
                          ::nRowPos = Min( nLines, nLen ) - ( ::oVScroll:nMax - nPos )
                          endif
                          ::Refresh( .F. )
                          if ::bChange <> nil
                          Eval( ::bChange, Self )
                          endif

                  otherwise
                          return nil
                          endcase
                          endif
                  endif

return 0



static FUNCTION TWBrowse2_HScroll( nWParam, nLParam ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nCol := ::nColPos






      local nScrHandle  := nLParam
      local nScrollCode := nLoWord( nWParam )
      local nPos        := nHiWord( nWParam )


   if ::oGet <> nil .AND. ! Empty( ::oGet:hWnd )
      ::oGet:End()
   endif

   do case
      case nScrollCode == 0
           ::GoLeft()

      case nScrollCode == 1
           ::GoRight()

      case nScrollCode == 2

           while ::nColPos > 1 .AND.  (::IsColVisible( nCol ) .OR. ::nColPos == nCol)
              ::nColPos--
           end
           ::nColAct := ::nColPos
           ::oHScroll:SetPos( ::nColAct )
           ::Refresh( .F. )

      case nScrollCode == 3

           while nCol < Len( ::GetColSizes() ) .AND.  (::IsColVisible( nCol ) .OR. ::nColPos == nCol)
              nCol++
           end
           ::nColPos := nCol
           ::nColAct := nCol
           ::oHScroll:SetPos( nCol )
           ::Refresh( .F. )

      case nScrollCode == 6
           ::nColPos = 1
           ::nColAct = 1
           ::oHScroll:SetPos( 1 )
           ::Refresh( .F. )

      case nScrollCode == 7
           ::nColPos = Len( ::GetColSizes() )
           ::nColAct = ::nColPos
           ::oHScroll:SetPos( ::nColPos )
           ::Refresh( .F. )

      case nScrollCode == 4
           ::nColPos = nPos
           ::nColAct = ::nColPos
           ::oHScroll:SetPos( nPos )
           ::Refresh( .F. )

      otherwise
           return nil
   endcase

return 0



static FUNCTION TWBrowse2_Skip( n ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   if ::bSkip <> nil
      return Eval( ::bSkip, n, Self )
   endif

return ( ::cAlias )->( __DbSkipper( n ) )



static function BrwGoBottom( uExpr )

   local lSoftSeek := Set( 9, .T. )

   if ValType( uExpr ) == "C"

      DbSeek( SubStr( uExpr, 1, Len( uExpr ) - 1 ) +  Chr( Asc( SubStr( uExpr, Len( uExpr ) ) ) + 1 ) )
   else
      DbSeek( uExpr + 1 )
   endif
   DbSkip( -1 )

   Set( 9, lSoftSeek )

return nil





static function BuildSkip( cAlias, cField, uValue1, uValue2 )

   local bSkipBlock
   local cType := ValType( uValue1 )

   do case
      case cType == "C"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= '" + uValue1 + "' .and." +  cField + "<= '" + uValue2 + "' }" ) ) ) }

      case cType == "D"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= CToD( '" + DToC( uValue1 ) + "') .and." +  cField + "<= CToD( '" + DToC( uValue2 ) + "') }" ) ) ) }

      case cType == "N"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= " + cValToChar( uValue1 ) + " .and." +  cField + "<= " + cValToChar( uValue2 ) + " }" ) ) ) }

      case cType == "L"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= " + cValToChar( uValue1 ) + " .and." +  cField + "<= " + cValToChar( uValue2 ) + " }" ) ) ) }
   endcase

return bSkipBlock



static function BrwGoTo( n, bWhile )

   local nSkipped := 0, nDirection := If( n > 0, 1, -1 )

   while nSkipped <> n .AND. Eval( bWhile ) .AND. ! EoF() .AND. ! BoF()
      DbSkip( nDirection )
      nSkipped += nDirection
   enddo

   do case
      case EoF()
         DbSkip( -1 )
         nSkipped += -nDirection

      case BoF()
         DbGoTo( RecNo() )
         nSkipped++

      case ! Eval( bWhile )
         DbSkip( -nDirection )
         nSkipped += -nDirection
   endcase

return nSkipped




static FUNCTION TWBrowse2__RecCount( uSeekValue ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nRecNo := ( ::cAlias )->( RecNo() )
   local nRecs  := 1
   local bField := &( "{ || " + ::cField + "}" )

   if ! ( ::cAlias )->( DbSeek( uSeekValue, .T. ) )

      if ( ::cAlias )->( Eval( bField, Self ) ) > ::uValue2  .OR. ( ::cAlias )->( EoF() )
         nRecs := 0
      endif
   endif



   if ::nMaxFilter == nil
      while ::Skip( 1 ) == 1
         nRecs++
      end
   else
      while ::Skip( 1 ) == 1 .AND. nRecs < ::nMaxFilter
         nRecs++
      end
   endif

   ( ::cAlias )->( DbGoTo( nRecNo ) )

return nRecs



static function GenLocal( aArray, nPos )

return { || If( nPos <= Len( aArray ), aArray[ nPos ], "  " ) }

static function GenBlock( bLine, nPos ) ;  return { || Eval( bLine )[ nPos ] }



static FUNCTION TWBrowse2_Report( cTitle, lPreview ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local oRpt
   local nRecNo := If( Upper( ::cAlias ) <> "ARRAY", ( ::cAlias )->( RecNo() ), 0 )
   local aData  := Eval( ::bLine, Self )
   local n
   local nCharWidth

   nCharWidth := GetTextWidth( 0, "B", If( ::oFont <> nil, ::oFont:hFont, 0 ))

   If( cTitle == nil, cTitle := ::oWnd:cTitle, ) ; If( lPreview == nil, lPreview := .T., );

   if lPreview


      oRpt := RptBegin({{|| cTitle}}, {{|| "Date: " + DToC( Date() ) + ", Time: " + Time()}}, {{|| "Page: " + Str( oRpt:nPage, 3 )}}, {}, {}, .F.,,,, .T.,,,,,, )
   else


      oRpt := RptBegin({{|| cTitle}}, {{|| "Date: " + DToC( Date() ) + ", Time: " + Time()}}, {{|| "Page: " + Str( oRpt:nPage, 3 )}}, {}, {}, .F.,,,, .F.,,,,,, )
   endif

   if Empty( oRpt ) .OR. oRpt:oDevice:hDC == 0
      return nil
   else
      Eval( ::bGoTop, Self )
   endif

   if ::aColSizes == nil
      ::aColSizes = Array( Len( aData ) )
      for n = 1 to Len( aData )
         ::aColSizes[ n ] = 80
      next
   else
      if Len( ::aColSizes ) < Len( aData )
         n = Len( ::aColSizes )
         while n++ < Len( aData )
            AAdd( ::aColSizes, 80 )
         end
      endif
   endif

   for n = 1 to Len( aData )
      if ValType( aData[ n ] ) <> "N"


         oRpt:AddColumn( TrColumn():New( { GenLocal( ::aHeaders, n ) },, { GenBlock( ::bLine, n ) }, Int( ::aColSizes[ n ]/ nCharWidth ),,,,,,,,, oRpt ) )
      else


         oRpt:AddColumn( TrColumn():New( { GenLocal( ::aHeaders, n ) },, { { || "   " } }, Int( ::aColSizes[ n ] / nCharWidth ),,,,,,,,, oRpt ) )
      endif
   next
   RptEnd()

   oRpt:bSkip = { || oRpt:Cargo := ::Skip( 1 ) }
   oRpt:Cargo = 1




   oRpt:Activate(, {|| If( Upper( ::cAlias ) == "ARRAY", oRpt:nCounter < Eval( ::bLogicLen, Self ), oRpt:Cargo == 1 )},,,,,,,,,,,, )

   if Upper( ::cAlias ) <> "ARRAY"
      ( ::cAlias )->( DbGoTo( nRecNo ) )
   endif
   ::Refresh()

return nil



static FUNCTION TWBrowse2_UpStable( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nRow   := ::nRowPos
   local nRecNo := ( ::cAlias )->( RecNo() )
   local nRows  := ::nRowCount()
   local n      := 1
   local lSkip  := .T.

   ::nRowPos    = 1
   ::GoTop()
   ::lHitTop    = .F.
   ::lHitBottom = .F.

   while ! ( ::cAlias )->( EoF() )
      if n > nRows
         ( ::cAlias )->( DbGoTo( nRecNo ) )
         ::nRowPos = nRow
         lSkip     = .F.
         exit
      endif
      if nRecNo == ( ::cAlias )->( RecNo() )
         ::nRowPos = n
         exit
      else
         ( ::cAlias )->( DbSkip() )
      endif
      n++
   end

   if lSkip
      ( ::cAlias )->( DbSkip( -::nRowPos ) )
   endif

   if ::bChange <> nil
      Eval( ::bChange, Self )
   endif

return nil



static FUNCTION TWBrowse2_SetFilter( cField, uVal1, uVal2 ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local cIndexType

   If( uVal2 == nil, uVal2 := uVal1, ) ;

   ::cField     = cField
   ::uValue1    = uVal1
   ::uValue2    = uVal2

   if uVal1 <> nil
      cIndexType := ( ::cAlias )->( ValType( &( IndexKey() ) ) )


      if ( ::cAlias )->( ValType( &cField ) ) <> cIndexType .OR.  ValType( uVal1 ) <> cIndexType .OR.  ValType( uVal2 ) <> cIndexType
         MsgAlert( "TWBrowse2 SetFilter() types don't match with current Index Key type!" )
      endif
   endif



   if ! Empty( ::cAlias )


      ::bGoTop     = If( uVal1 <> nil, { || ( ::cAlias )->( DbSeek( uVal1, .T. ) ) }, { || ( ::cAlias )->( DbGoTop() ) } )


      ::bGoBottom  = If( uVal2 <> nil, { || ( ::cAlias )->( BrwGoBottom( uVal2 ) ) }, { || ( ::cAlias )->( DbGoBottom() ) } )


      ::bSkip      = If( uVal1 <> nil, BuildSkip( ::cAlias, cField, uVal1, uVal2 ), { | n | ( ::cAlias )->( __DbSkipper( n ) ) } )



      ::bLogicLen  = If( uVal1 <> nil, { || ( ::cAlias )->( Self:RecCount( uVal1 ) ) }, { || ( ::cAlias )->( RecCount() ) } )

      ::nLen       = Eval( ::bLogicLen, Self )

      ::lHitTop    = .F.
      ::lHitBottom = .F.

      if uVal1 <> nil
         Eval( ::bGoTop, Self )
      endif
   else
      ::bLogiclen = { || 0 }
   endif

return nil



static FUNCTION TWBrowse2_MouseMove( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nColPos := 0
   local aColSizes

   if ::lDrag
      return ::TControl:MouseMove( nRow, nCol, nKeyFlags )
   endif

   if ::lCaptured
      CursorWE()
      ::VertLine( nCol )
      return 0
   endif
   aColSizes := ::GetColSizes()



   if ::lMChange .AND. AScan( aColSizes, { | nColumn | nColPos += nColumn, nCol >= nColPos - 1 .AND.  nCol <= nColPos + 1 }, ::nColPos ) <> 0
      if nColPos > aColSizes[1]+2
         CursorWE()
      endif
   else
      if !empty( ::aRectBtn ) .AND. PtInRect( nRow, nCol, ::aRectBtn )
         CursorHand()
      else
         ::TControl:MouseMove( nRow, nCol, nKeyFlags )
      endif
   endif

return 0



static FUNCTION TWBrowse2_MouseWheel( nKeys, nDelta, nXPos, nYPos ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local aPos := { nYPos, nXPos }

   aPos = ScreenToClient( ::hWnd, aPos )








      if lAnd( nKeys, 16 )
         if nDelta > 0
            ::PageUp()
         else
            ::PageDown()
         endif
      else
         if nDelta > 0
            ::GoUp()
         else
            ::GoDown()
         endif
      endif


return nil










static FUNCTION TWBrowse2_VertLine( nColPos, nColInit ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local oRect, aSizes, nFor

   static nCol, nWidth, nMin, nOldPos := 0

   if nColInit <> nil
      nCol    = nColInit
      nWidth  = nColPos
      nOldPos = 0
      nMin := 0
      aSizes := ::GetColSizes()

      FOR nFor := ::nColPos TO nColInit - 1
          nMin += aSizes[nFor]
      NEXT

      nMin += 5
   endif

   if nColPos == nil .AND. nColInit == nil
      ::aColSizes[ nCol ] -= ( nWidth - nOldPos )
      ::Refresh()
   endif

   if nColPos <> nil
     nColPos := Max(nColPos, nMin)
   endif

   oRect = ::GetRect()
   ::GetDC()
   if nOldPos <> 0
      InvertRect( ::hDC, { 0, nOldPos - 2, oRect:nBottom, nOldPos + 2 } )
      nOldPos = 0
   endif
   if nColPos <> nil .AND. ( nColPos - 2 ) > 0
      InvertRect( ::hDC, { 0, nColPos - 2, oRect:nBottom, nColPos + 2 } )
      nOldPos = nColPos
   endif
   ::ReleaseDC()

return nil



static FUNCTION TWBrowse2_nAtCol( nColPixel ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nColumn := ::nColPos - 1
   local aSizes  := ::GetColSizes()
   local nPos    := 0

   If( nColPixel == nil, nColPixel := 0, ) ;

   while nPos < nColPixel .AND. nColumn < Len( aSizes )
      nPos += aSizes[ nColumn + 1 ]
      nColumn++
   end

return nColumn



static FUNCTION TWBrowse2_nAtIcon( nRow, nCol ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nIconsByRow := Int( ::nWidth() / 50 )

   nRow -= 9
   nCol -= 1

   if ( nCol % 50 ) >= 9 .AND. ( nCol % 50 ) <= 41
      return Int( ( nIconsByRow * Int( nRow / 50 ) ) + Int( nCol / 50 ) ) + 1
   else
      return 0
   endif

return nil



static FUNCTION TWBrowse2_Display( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nRecs

   ::BeginPaint()
   if ::oVScroll <> nil
      nRecs := Eval( ::bLogicLen, Self )
      if ::VGetMax() <> nRecs .OR. nRecs <> ::nLen
         ::nLen := nRecs
         ::VSetRange()
         ::oVScroll:SetPage( Min( ::nRowCount(), ::nLen - 1 ), .T. )
      endif
   endif
   if ::oHScroll <> nil

      ::oHScroll:SetRange( 0, 0 )
   endif
   ::Paint()
   ::EndPaint()

return 0



static FUNCTION TWBrowse2_GetDlgCode( nLastKey ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2




   if ! ::oWnd:lValidating

      if nLastKey == 38 .OR. nLastKey == 40  .OR. nLastKey == 13 .OR. nLastKey == 9
         ::oWnd:nLastKey = nLastKey
      else
         ::oWnd:nLastKey = 0
      endif
   endif

return If( IsWindowEnabled( ::hWnd ), 4, 0 )



static function _aFields( Self )

   local aFld, aSizes, cAlias := ::cAlias
   local nCols, nFirstCol, nLastCol, nWidth, nBrwWidth

   if Empty( cAlias )
      return {}
   endif

   if Len( ::aColSizes ) == 0
      return Array( ( cAlias )->( Fcount() ) )
   endif

  aSizes    = ::aColSizes
  nCols     = Len( aSizes )
  nFirstCol = ::nColPos
  nLastCol  = nFirstCol
  nWidth    = 0
  nBrwWidth = ::nWidth()
  aFld      = Array( nCols )

  AFill( aFld, "" )

  while nWidth < nBrwWidth .AND. nLastCol <= nCols
     nWidth += aSizes[ nLastCol ]
     if ValType( ( cAlias )->( FieldGet( nLastCol ) ) ) == "M"

        aFld[ nLastCol ] = If( ! Empty( ( cAlias )->(  FieldGet( nLastCol ) ) ), "<Memo>", "<memo>" )
        nLastCol++
     else
        aFld[ nLastCol ] = cValToChar( ( cAlias )->( FieldGet( nLastCol ) ) )
        nLastCol++
     endif
  end

return aFld



static FUNCTION TWBrowse2_SetCols( aData, aHeaders, aColSizes ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local aFields
   local nElements, n

   nElements   := Len( aData )

   ::aHeaders  := If( aHeaders  <> nil, aHeaders, ::aHeaders )
   ::aColSizes := If( aColSizes <> nil, aColSizes, {} )
   ::bLine     := {|| _aData( aData ) }
   ::aJustify  := AFill( Array( nElements ), .F. )

   if Len( ::GetColSizes() ) < nElements
      ::aColSizes = AFill( Array( nElements ), 0 )
      aFields = Eval( ::bLine, Self )
      for n = 1 to nElements





          ::aColSizes[ n ] := If( ValType( aFields[ n ] ) <> "C", 15, GetTextWidth( 0, Replicate( "B",  Max( Len( ::aHeaders[ n ] ),  Len( aFields[ n ] ) ) + 1 ), If( ! Empty( ::oFont ), ::oFont:hFont,) ) )
      next
   endif

   if ::oHScroll <> nil
      ::oHScroll:nMax := ::GetColSizes()
   endif

return nil



static FUNCTION TWBrowse2_ShowSizes( ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local cText := ""


   AEval( ::aColSizes, { | v,e | cText += ::aHeaders[ e ] + ": " + Str( v, 3 ) + Chr(13)+Chr(10) } )

   MsgInfo( cText )

return nil



static FUNCTION TWBrowse2__DrawIcon( nIcon, lFocused ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nIconsByRow := Int( ::nWidth() / 50 )
   local nRow := Int( --nIcon / nIconsByRow )
   local nCol := If( nRow > 0, nIcon % ( nRow * nIconsByRow ), nIcon )

   If( lFocused == nil, lFocused := .F., ) ;

   if lFocused

      DrawIconFocus( ::GetDC(), ( nRow * 50 ) + 10, ( nCol * 50 ) + 10, ExtractIcon( "user.exe" ) )
   else

      DrawIcon( ::GetDC(), ( nRow * 50 ) + 10, ( nCol * 50 ) + 10, ExtractIcon( "user.exe" ) )
   endif

return nil



static FUNCTION TWBrowse2_IsColVisible( nCol ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2

   local nCols, nFirstCol, nLastCol, nWidth, nBrwWidth

   nCols     := Len( ::GetColSizes() )
   nFirstCol := ::nColPos
   nLastCol  := nFirstCol
   nWidth    := 0
   nBrwWidth := ::nWidth - If( ::oVScroll <> nil, 16, 0 )

   if nCol < nFirstCol
      return .F.
   endif

   while nWidth < nBrwWidth .AND. nLastCol <= nCol
      nWidth += ::GetColSizes()[ nLastCol ]
      nLastCol++
   end

   if nCol <= --nLastCol


      if nWidth > nBrwWidth
          return .F.
      endif

      return .T.

   endif

return .F.



static function _aData( aFields )

  local aFld
  local nFor, nLen

  nLen = Len( aFields )
  aFld = Array( nLen )

  for nFor = 1 to nLen
     aFld[ nFor ] = Eval( aFields[ nFor ] )
  next

return aFld








static FUNCTION TWBrowse2_wBrwLine( hWnd, hDC, nRowPos, aValues, aColSizes, nColPos, nClrText, nClrPane, hFont, lTree, aJustify, nPressed, nLineStyle, nColAct, lFocused, oVScroll, bLogicLen, lBar ) ; local Self AS CLASS TWBrowse2 := QSelf() AS CLASS TWBrowse2
   local nTxtHeight, hOldFont
   local nColStart  := -1
   local rc := GetClientRect( hWnd )
   local nWidth     := (rc[4]-rc[2])
   local nRow := nRowPos, nTop, nBottom, nLeft, nRight, n
   local lReleaseDC := .F.
   local nForeColor, nBackColor
   local  hPen, hOld, hBrush
   local hFontBold, nLenText
   local cValue

   If( lTree == nil, lTree := .F., ) ; If( lBar == nil, lBar := .F., );

   if Empty( hDC )
      hDC = GetDC( hWnd )
      lReleaseDC = .T.
   endif








   nTxtHeight = ::nHLine

   nTop    = nTxtHeight * nRow
   nBottom = nTop + nTxtHeight - 1


   SetTextColor( hDC, If( ValType( nClrText ) == "B", nClrText := Eval( nClrText ), nClrText ) )

   SetBkColor( hDC, If( ValType( nClrPane ) == "B", nClrPane := Eval( nClrPane ), nClrPane ) )

   for n := nColPos to Len( aValues )

      if valtype( aValues[1]) == "N" .AND. n == 2 .AND. aValues[1] <> 0
         hFontBold  := CreateBold( hFont )
         hOldFont   = SelectObject( hDC, hFontBold )
      else
         hOldFont   = SelectObject( hDC, hFont )
      endif

      nLeft   = nColStart + 1
      nRight  = Min( nColStart := ( nLeft + aColSizes[ n ] - 1 ), nWidth )
      if nLeft > nWidth
         exit
      endif
      if n == Len( aValues )
         nRight = nWidth
      endif

      if ValType( aValues[ n ] ) == "N" .OR. nRowPos == 0
         if n <= 1
            hBrush = CreateSolidBrush( ( 212 + ( 208 * 256 ) + ( 200 * 65536 ) ) )
         else



               hBrush = CreateSolidBrush( GetBkColor( hDC ) )

         endif
         hOld   = SelectObject( hBrush )


         FillRect( hDC, { nTop, nLeft, nBottom, nRight + If( ( nLineStyle ==  0 .OR. nLineStyle == 8 .OR. nLineStyle ==  7 ) .AND. nRowPos <> 0, 2, 0 ) }, hBrush )
         DrawMasked( hDC, aValues[ n ], nTop+3, nLeft + 0 )
         SelectObject( hOld )
         DeleteObject( hBrush )
      else
         if nColAct <> nil .AND. n == nColAct
            SetTextColor( hDC, nClrText )
            SetBkColor( hDC, nClrPane )
         else
            if nRowPos <> 0
               if n == 3
                  SetTextColor( hDC, ::nClrText )
                  if aValues[1] <> 0
                     SetBkColor( hDC, ( 212 + ( 208 * 256 ) + ( 200 * 65536 ) ) )
                  else
                     SetBkColor( hDC, ::nClrPane )
                  endif
               else
                  SetTextColor( hDC, If( nColAct <> nil, GetSysColor( 18 ), if( aValues[1] <> 0,::nClrText,nClrText) ) )
                  SetBkColor( hDC, If( nRowPos == 0, ( 212 + ( 208 * 256 ) + ( 200 * 65536 ) ) , If( nColAct == nil, if( aValues[1] <> 0,( 212 + ( 208 * 256 ) + ( 200 * 65536 ) ),nClrPane), GetSysColor( 5 ) ) ) )
               endif
            endif
         endif

         if nRowPos <> 0 .AND. !::aItems[::nGetElement(::nAt),8]
            SetTextColor( hDC, 12632256 )
         endif

         if ! lTree





            if aJustify <> nil .AND. aJustify[ n ]
               SetTextAlign( hDC, 2 )




               ExtTextOut( hDC, nTop, nRight - 2, { nTop, nLeft, nBottom, nRight + If( (nLineStyle ==  0 .OR. nLineStyle == 8 .OR.  nLineStyle == 7 ) .AND. nRowPos <> 0, 2, 0 ) }, "" )


               DrawText( hDC, cValToChar( aValues[n] ), { nTop, nLeft+3, nBottom, nRight + If( (nLineStyle ==  0 .OR. nLineStyle == 8 .OR.  nLineStyle == 7 ) .AND. nRowPos <> 0, 2, 0 ) }, nOr( 4, 2,32 ) )

            else





               ExtTextOut( hDC, nTop, nLeft + 2, { nTop, nLeft, nBottom, nRight + If( ( nLineStyle ==  0 .OR. nLineStyle == 8 .OR.  nLineStyle == 7 ) .AND. nRowPos <> 0, 2, 0 ) }, "" )
               cValue := strtran(strtran(cValToChar( aValues[n] ),".T.","True"),".F.","False")


               DrawText( hDC, cValue, { nTop, nLeft+3, nBottom, nRight + If( (nLineStyle ==  0 .OR. nLineStyle == 8 .OR.  nLineStyle == 7 ) .AND. nRowPos <> 0, 2, 0 ) }, nOr( 4, 32768,32 ) )


            endif

            if lBar
               if n == 2 .AND. aValues[1] <> 0
                  nLenText := GetTextWidth( hDC, aValues[n], hFontBold )
                  DrawFocusRect( hDC, nTop+3, nLeft, nTop+18, nLeft+nLenText + 8 )
               endif
            endif


         else

            DrawText( hDC, cValToChar( aValues[ n ] ), { nTop, nLeft + 4, nBottom, nRight } )
         endif
      endif
      if ! lTree
         if nRowPos == 0




         else
            nLeft += 1
            do case
               case nLineStyle == 1
                    WndBox( hDC, nTop - 1, nLeft - 1, nBottom, nRight )

               case nLineStyle == 2
                    hPen = CreatePen( 0, 1, ( 212 + ( 208 * 256 ) + ( 200 * 65536 ) ) )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 2, nTop - 2 )
                    LineTo( hDC, nLeft - 2, nBottom )
                    LineTo( hDC, nRight , nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )

               case nLineStyle == 3
                    WndBoxRaised( hDC, nTop, nLeft, nBottom, nRight )

               case nLineStyle == 4
                    SetTextColor( hDC, 0 )
                    FrameDot( hDC, nTop - 1, nLeft - 1, nBottom, nRight )

               case nLineStyle == 5
                    hPen = CreatePen( 0, 1, 0 )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 1, nTop - 2 )
                    LineTo( hDC, nLeft - 1, nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )

               case nLineStyle == 6
                    hPen = CreatePen( 0, 1, 8421504 )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 1, nTop - 2 )
                    LineTo( hDC, nLeft - 1, nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )

               case nLineStyle == 7
                    hPen = CreatePen( 0, 1, 0 )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 2, nBottom )
                    LineTo( hDC, nRight , nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )

               case nLineStyle == 8
                    hPen = CreatePen( 0, 1, 8421504 )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 2, nBottom )
                    LineTo( hDC, nRight , nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )
            endcase
         endif
      endif

      if nColPos > nWidth
         exit
      endif
      SelectObject( hDC, hOldFont )
      if hFontBold <> nil
         DeleteObject( hFontBold )
      endif

   next



   if lReleaseDC
      ReleaseDC( hWnd, hDC )
   endif

return nil






























#pragma BEGINDUMP

#include <windows.h>
#include <winuser.h>
#include <wingdi.h>
#include "hbapi.h"


HB_FUNC( CREATEBOLD )
{
        LOGFONT lf;
      GetObject( ( HFONT ) hb_parnl( 1 ) , sizeof( LOGFONT ), &lf );
      lf.lfWeight = FW_BOLD;
                  hb_retnl( (LONG) CreateFontIndirect( &lf ));
}

HB_FUNC( WBRWSCROLL ) // ( hWnd, nRows, hFont ) --> nil
{
   HWND hWnd   = ( HWND ) hb_parnl( 1 );
   int wRows  = hb_parni( 2 );
   HFONT hFont = ( HFONT ) hb_parnl( 3 );
   HFONT hOldFont;
   HDC hDC     = GetDC( hWnd );
   int nHLine = hb_parni( 4 );
   RECT rct;
   TEXTMETRIC tm;

   if( hFont )
      hOldFont = ( HFONT ) SelectObject( hDC, hFont );

   GetClientRect( hWnd, &rct );
   GetTextMetrics( hDC, &tm );
   tm.tmHeight = nHLine;

   rct.top += tm.tmHeight;
   //rct.bottom -= ( ( rct.bottom - rct.top ) % tm.tmHeight );

   ScrollWindowEx( hWnd, 0, -( tm.tmHeight * wRows ), 0, &rct, 0, 0, 0 );

   if( hFont )
      SelectObject( hDC, hOldFont );

   ReleaseDC( hWnd, hDC );
}

HB_FUNC( DRAWFRAMECONTROL )
{
      RECT rc;
      rc.top    = hb_parvni( 2, 1);
      rc.left   = hb_parvni( 2, 2);
      rc.bottom = hb_parvni( 2, 3);
      rc.right  = hb_parvni( 2, 4);

       hb_retl( DrawFrameControl( (HDC) hb_parnl( 1 ), &rc, hb_parni( 3 ), hb_parni( 4 ) ) );
}
HB_FUNC( DRAWFOCUSRECT )  //RECT

{
   RECT rct ;
   HDC  hDC = ( HDC ) hb_parni( 1 );

   rct.top    = hb_parvni( 2 );
   rct.left   = hb_parvni( 3 );
   rct.bottom = hb_parvni( 4 );
   rct.right  = hb_parvni( 5 );

   DrawFocusRect( hDC, &rct );

}


HB_FUNC( PTINRECT )
{
   POINT pt;
   RECT  rct;

   pt.y = hb_parnl( 1 );
   pt.x = hb_parnl( 2 );

   rct.top    = hb_parvni( 3, 1 );
   rct.left   = hb_parvni( 3, 2 );
   rct.bottom = hb_parvni( 3, 3 );
   rct.right  = hb_parvni( 3, 4 );

   hb_retl( PtInRect( &rct, pt ) );
}


HB_FUNC( HWNDCOMBO )
{
   COMBOBOXINFO cbi      ;
   ZeroMemory( &cbi, sizeof( COMBOBOXINFO ) );
   cbi.cbSize = sizeof(COMBOBOXINFO);

   GetComboBoxInfo( (HWND) hb_parnl( 1 ), &cbi );

   hb_retnl( (LONG)cbi.hwndCombo ) ;
}

HB_FUNC( HWNDCOMBOEDIT )
{
   COMBOBOXINFO cbi      ;
   ZeroMemory( &cbi, sizeof( COMBOBOXINFO ) );
   cbi.cbSize = sizeof(COMBOBOXINFO);

   GetComboBoxInfo( (HWND) hb_parnl( 1 ), &cbi );

   hb_retnl( (LONG)cbi.hwndItem ) ;
   //hb_retnl( (LONG)cbi.hwndList ) ;
}

HB_FUNC( HWNDCOMBOLIST )
{
   COMBOBOXINFO cbi      ;
   ZeroMemory( &cbi, sizeof( COMBOBOXINFO ) );
   cbi.cbSize = sizeof(COMBOBOXINFO);

   GetComboBoxInfo( (HWND) hb_parnl( 1 ), &cbi );

   hb_retnl( (LONG)cbi.hwndList ) ;
}




#pragma ENDDUMP



_HB_CLASS TProperty ; function TProperty ( ... ) ; static s_oClass ; local nScope, oClass, oInstance ; if s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; begin sequence ; nScope := 1 ; ( ( nScope ) ) ; oClass := IIF(.F.,, HBClass():new( "TProperty" , iif( .F., { }, { @HBObject() } ), @TProperty() ) ) ;

; _HB_MEMBER { oObject } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oObject"}, .F. )
; _HB_MEMBER { cProperty } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cProperty"}, .F. )
; _HB_MEMBER { cText } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cText"}, .F. )
; _HB_MEMBER { bProperty } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bProperty"}, .F. )
; _HB_MEMBER { bEditor } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bEditor"}, .F. )
; _HB_MEMBER { cType } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cType"}, .F. )
; _HB_MEMBER { lEnable } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lEnable"}, .F. )
; _HB_MEMBER { lOpen } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lOpen"}, .F. )
; _HB_MEMBER { nItem } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nItem"}, .F. )
; _HB_MEMBER { nGroup } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nGroup"}, .F. )

      _HB_MEMBER New( oObject, cProperty, cText, bProperty, cType, lEnable, lAbierto, bEditor, nItem, nGroup) AS CLASS TProperty; oClass:AddMethod( "New", @TProperty_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

      _HB_MEMBER Set(); oClass:AddInline( "Set", {|Self, uValue | ( ( Self ) ), oSend( ::oObject,"_" + ::cProperty, uValue ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Get(); oClass:AddInline( "Get", {|Self | ( ( Self ) ), if( ::cType <> "G", oSend( ::oObject, ::cProperty ),"") }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
      _HB_MEMBER Valtype(); oClass:AddInline( "Valtype", {|Self | ( ( Self ) ), Valtype( ::Get() ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


oClass:Create() ; ; oInstance := oClass:Instance() ; if __ObjHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; end ; always ; __clsUnlockDef( @s_oClass, oClass ) ; end ; return oInstance ; end ; return s_oClass:Instance() AS CLASS TProperty ;


  static FUNCTION TProperty_New( oObject, cProperty, cText, bProperty, cType, lEnable, lAbierto, bEditor, nItem, nGroup ) ; local Self AS CLASS TProperty := QSelf() AS CLASS TProperty


If( cType == nil, cType := "", ) ;



   ::oObject    := oObject
   ::cProperty  := cProperty
   ::cText      := cText
   ::bProperty  := bProperty
   ::bEditor    := bEditor
   ::cType      := cType
   ::lEnable    := lEnable
   ::lOpen      := lAbierto
   ::nItem      := nItem
   ::nGroup     := nGroup

return self


function oCbxComponentes(); return oCbxComponentes
function oProperties(); return oWnd1
