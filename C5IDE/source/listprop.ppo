#line 38 "\fwh\include\FiveWin.ch"
      static bError
#line 219 "hbclass.ch"
DECLARE HBClass  New( cName AS STRING, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS OBJECT  Instance() AS OBJECT  AddClsMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC, n2 AS NUMERIC, n3 AS NUMERIC )  AddMultiClsData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING )  AddMultiData( cType AS STRING, uVal, nScope AS NUMERIC, aDatas AS ARRAY OF STRING, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS STRING, @MethodName(), nScope AS NUMERIC )  AddInLine( cName AS STRING, bBlock AS CODEBLOCK, nScope AS NUMERIC )  AddVirtual( cName AS STRING )
#line 79 "\fwh\include\FiveWin.ch"
         EXTERNAL FW_GT











extern errorsys
#line 147 "source\listprop.prg"
extern DBSKIP

static aClient
static oBrw := nil





function WndFold( )
local oTab
local oWnd
local oBrush
local oBar, oList
local o
local aClient := GetClientRect( Aplicacion():oWnd:hWnd )
local oSplit
local aClient2
local cTitle := ""
local nStyle

oBrush := TBrush():New( Upper("NULL"),,,,, )

if Aplicacion():oToolBox <> nil
   Aplicacion():oToolBox:Show()
else

Aplicacion():oToolBox := TWindow():New( Aplicacion():nTopTool, Aplicacion():nLeftTool, Aplicacion():nBottomTool, Aplicacion():nRightTool, "ToolBox",,,,,,,,,,,, !.F., !.F., !.T., !.T., .T. )


          oBar  := ToolBar( 405, 0, 281, 330, Aplicacion():oToolBox )

Aplicacion():oToolBox:oClient := oBar









Aplicacion():oToolBox:ToolWindow()
Aplicacion():oToolBox:Show()
Aplicacion():oToolBox:Resize()

endif

return nil


function ResizeToolBox( oList, oBar, oSplit )
local rc := GetClientRect( Aplicacion():oToolBox:hWnd )

oSplit:nWidth := rc[4]
oList:nWidth := rc[4]
oBar:nWidth := rc[4]


return 0


function ListProp( oPage, oInspect )

local oFont
local oCbx
local aControles := {""}
local cVar := ""

      oFont := TFont():New( "Ms Sans Serif", 0, -11,,,,,,,,,,,,,, )




      oBrw := TInspector():New( 0, 0, 280, 400, {|| {"", "" } }, {"Property", "Value"}, {80, 200}, oPage,,,,,,, oFont,,,,, .F.,, .T.,, .F.,,, )



      oBrw:nAt       = 1
      oBrw:bGoTop    = { || oBrw:nAt := 1 }
      oBrw:bGoBottom = { || oBrw:nAt := Eval( oBrw:bLogicLen ) }
      oBrw:bLogicLen = { || If( oInspect <> nil, oInspect:PropCount(), 0 ) }

      oBrw:bLine     = { || { oInspect:Property( oBrw:nAt ), cValToChar( OSend( oInspect, oInspect:Property( oBrw:nAt ) ) ) } }




      oBrw:bSkip     = { | nSkip, nOld | nOld := oBrw:nAt, oBrw:nAt += nSkip, oBrw:nAt := Min( Max( oBrw:nAt, 1 ), Eval( oBrw:bLogicLen ) ), oBrw:nAt - nOld }
      oBrw:bKeyChar  := { | nKey | If( nKey == 13, oBrw:EditData(),) }
      oBrw:bGotFocus := {|| oBrw:Refresh() }
      Aplicacion():oInspector := oBrw



return oBrw

_HB_CLASS TListProp ; function TListProp ( ... ) ; static s_oClass ; local nScope, oClass, oInstance ; if s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; begin sequence ; nScope := 1 ; ( ( nScope ) ) ; oClass := IIF(.F.,, HBClass():new( "TListProp" , iif( .F., { }, { @HBObject() } ), @TListProp() ) ) ;

oClass:Create() ; ; oInstance := oClass:Instance() ; if __ObjHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; end ; always ; __clsUnlockDef( @s_oClass, oClass ) ; end ; return oInstance ; end ; return s_oClass:Instance() AS CLASS TListProp ;


_HB_CLASS TInspector ; function TInspector ( ... ) ; static s_oClass ; local nScope, oClass, oInstance ; if s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; begin sequence ; nScope := 1 ; ( ( nScope ) ) ; oClass := IIF(.F.,, HBClass():new( "TInspector" , iif( .T., { @TControl() }, { @HBObject() } ), @TInspector() ) ) ;

 ; ; ;; _HB_MEMBER { cAlias, cField, uValue1, uValue2 } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"cAlias", "cField", "uValue1", "uValue2"}, .F. )
 ; ; ; ; ; ;; _HB_MEMBER { bLine, bSkip, bGoTop, bGoBottom, bLogicLen, bChange, bAdd } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"bLine", "bSkip", "bGoTop", "bGoBottom", "bLogicLen", "bChange", "bAdd"}, .F. )
 ; ; ; ;; _HB_MEMBER { nRowPos, nColPos, nLen, nAt, nColAct } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nRowPos", "nColPos", "nLen", "nAt", "nColAct"}, .F. )
; _HB_MEMBER { nMaxFilter } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nMaxFilter"}, .F. )

 ; ; ;; _HB_MEMBER { lHitTop, lHitBottom, lCaptured, lMChange } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lHitTop", "lHitBottom", "lCaptured", "lMChange"}, .F. )
 ;; _HB_MEMBER { lAutoEdit, lAutoSkip } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lAutoEdit", "lAutoSkip"}, .F. )
; _HB_MEMBER { AS LOGICAL lCellStyle } ; oClass:AddMultiData( "LOGICAL", .F., nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lCellStyle"}, .F. )
 ;; _HB_MEMBER { aHeaders, aColSizes } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aHeaders", "aColSizes"}, .F. )
 ;; _HB_MEMBER { nClrBackHead, nClrForeHead } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrBackHead", "nClrForeHead"}, .F. )
 ;; _HB_MEMBER { nClrBackFocus, nClrForeFocus } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nClrBackFocus", "nClrForeFocus"}, .F. )
 ;; _HB_MEMBER { aJustify, aActions } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aJustify", "aActions"}, .F. )
 ;; _HB_MEMBER { oGet, oBtn } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oGet", "oBtn"}, .F. )
; _HB_MEMBER { nLineStyle } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nLineStyle"}, .F. )
 ; ; ;; _HB_MEMBER { lIconView, aIcons, bIconDraw, bIconText } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lIconView", "aIcons", "bIconDraw", "bIconText"}, .F. )
 ;; _HB_MEMBER { nIconPos, nVScrollPos } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nIconPos", "nVScrollPos"}, .F. )
; _HB_MEMBER { nHLine } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"nHLine"}, .F. )
; _HB_MEMBER { oInspect } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"oInspect"}, .F. )
; _HB_MEMBER { lEditing } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lEditing"}, .F. )
; _HB_MEMBER { aRectBtn } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"aRectBtn"}, .F. )

   _HB_MEMBER { AS LOGICAL lRegistered } ; oClass:AddMultiClsData( "LOGICAL",, nScope + iif( .F., 16, 0 ) + iif( .T., 32, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"lRegistered"}, .F. )





   _HB_MEMBER New( nRow, nCol, nWidth, nHeigth, bLine, aHeaders,  aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nForeBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions) AS CLASS TInspector; oClass:AddMethod( "New", @TInspector_New(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER ReDefine( nId, bLine, oDlg, aHeaders, aColSizes, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, bWhen, bValid, bLClick, aActions) AS CLASS TInspector; oClass:AddMethod( "ReDefine", @TInspector_ReDefine(), nScope + iif( .T., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER nAtCol( nCol); oClass:AddMethod( "nAtCol", @TInspector_nAtCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER nAtIcon( nRow, nCol); oClass:AddMethod( "nAtIcon", @TInspector_nAtIcon(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER lCloseArea(); oClass:AddInline( "lCloseArea", {|Self | ( ( Self ) ), If( ! Empty( ::cAlias ), ( ::cAlias )->( DbCloseArea() ),), If( ! Empty( ::cAlias ), ::cAlias := "",), .T. }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER LDblClick( nRow, nCol, nKeyFlags); oClass:AddMethod( "LDblClick", @TInspector_LDblClick(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Default(); oClass:AddMethod( "Default", @TInspector_Default(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER BugUp(); oClass:AddInline( "BugUp", {|Self | ( ( Self ) ), ::UpStable() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Display(); oClass:AddMethod( "Display", @TInspector_Display(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DrawIcons(); oClass:AddMethod( "DrawIcons", @TInspector_DrawIcons(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )







   _HB_MEMBER DrawLine(); oClass:AddInline( "DrawLine", {|Self, nRow | ( ( Self ) ), ::wBrwLine( ::hWnd, ::hDC, If( nRow == nil, ::nRowPos, nRow ),  Eval( ::bLine, Self ), ::GetColSizes(), ::nColPos, ::nClrText, ::nClrPane, If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify, nil, ::nLineStyle,,, ::oVScroll, ::bLogicLen  ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DrawSelect(); oClass:AddMethod( "DrawSelect", @TInspector_DrawSelect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER lEditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction); oClass:AddMethod( "lEditCol", @TInspector_lEditCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Edit( nCol, lModal); oClass:AddMethod( "Edit", @TInspector_Edit(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER EditCol( uVar, aItems, bAction); oClass:AddMethod( "EditCol", @TInspector_EditCol(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER EraseBkGnd(); oClass:AddInline( "EraseBkGnd", {|Self, hDC | ( ( Self ) ), 1 }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER GetColSizes(); oClass:AddInline( "GetColSizes", {|Self | ( ( Self ) ), If( ValType( ::aColSizes ) == "A", ::aColSizes, Eval( ::aColSizes, Self ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GetDlgCode( nLastKey); oClass:AddMethod( "GetDlgCode", @TInspector_GetDlgCode(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER GoUp(); oClass:AddMethod( "GoUp", @TInspector_GoUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoDown(); oClass:AddMethod( "GoDown", @TInspector_GoDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoLeft(); oClass:AddMethod( "GoLeft", @TInspector_GoLeft(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoRight(); oClass:AddMethod( "GoRight", @TInspector_GoRight(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoTop(); oClass:AddMethod( "GoTop", @TInspector_GoTop(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER GoBottom(); oClass:AddMethod( "GoBottom", @TInspector_GoBottom(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER GotFocus(); oClass:AddInline( "GotFocus", {|Self | ( ( Self ) ), ::TControl:GotFocus(), If( ::nLen > 0 .AND. ! Empty( ::cAlias ) .AND.  ! ::lIconView, ::DrawSelect(),) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER HScroll( nWParam, nLParam); oClass:AddMethod( "HScroll", @TInspector_HScroll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER DrawIcon(); oClass:AddMethod( "DrawIcon", @TInspector__DrawIcon(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Initiate(); oClass:AddInline( "Initiate", {|Self, hDlg | ( ( Self ) ), ::TControl:Initiate( hDlg ), ::Default() }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER IsColVisible( nCol); oClass:AddMethod( "IsColVisible", @TInspector_IsColVisible(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER KeyDown( nKey, nFlags); oClass:AddMethod( "KeyDown", @TInspector_KeyDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER KeyChar( nKey, nFlags); oClass:AddMethod( "KeyChar", @TInspector_KeyChar(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LButtonDown( nRow, nCol, nKeyFlags); oClass:AddMethod( "LButtonDown", @TInspector_LButtonDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER LButtonUp( nRow, nCol, nKeyFlags); oClass:AddMethod( "LButtonUp", @TInspector_LButtonUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER LostFocus(); oClass:AddInline( "LostFocus", {|Self, hCtlFocus | ( ( Self ) ), ::TControl:LostFocus( hCtlFocus ), If( ::nLen > 0 .AND. ! Empty( ::cAlias ) .AND.  ! ::lIconView, ::DrawSelect(),) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER MouseMove( nRow, nCol, nKeyFlags); oClass:AddMethod( "MouseMove", @TInspector_MouseMove(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER MouseWheel( nKeys, nDelta, nXPos, nYPos); oClass:AddMethod( "MouseWheel", @TInspector_MouseWheel(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PageUp( nLines); oClass:AddMethod( "PageUp", @TInspector_PageUp(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER PageDown( nLines); oClass:AddMethod( "PageDown", @TInspector_PageDown(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Paint(); oClass:AddMethod( "Paint", @TInspector_Paint(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RecAdd(); oClass:AddInline( "RecAdd", {|Self | ( ( Self ) ), If( ::bAdd <> nil, Eval( ::bAdd, Self ),) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER RecCount(); oClass:AddMethod( "RecCount", @TInspector__RecCount(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER Report( cTitle, lPreview); oClass:AddMethod( "Report", @TInspector_Report(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER ReSize( nSizeType, nWidth, nHeight); oClass:AddMethod( "ReSize", @TInspector_ReSize(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER nRowCount(); oClass:AddInline( "nRowCount", {|Self | ( ( Self ) ), aClient := GetClientRect(::hWnd), int( ( aClient[3]-aClient[1]) / ::nHLine )-1 }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER SetArray( aArray); oClass:AddMethod( "SetArray", @TInspector_SetArray(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetCols( aData, aHeaders, aColSizes); oClass:AddMethod( "SetCols", @TInspector_SetCols(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetFilter( cField, uVal1, uVal2); oClass:AddMethod( "SetFilter", @TInspector_SetFilter(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER SetTree( oTree); oClass:AddMethod( "SetTree", @TInspector_SetTree(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER ShowSizes(); oClass:AddMethod( "ShowSizes", @TInspector_ShowSizes(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER Skip( n); oClass:AddMethod( "Skip", @TInspector_Skip(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER UpStable(); oClass:AddMethod( "UpStable", @TInspector_UpStable(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VertLine( nColPos, nColInit); oClass:AddMethod( "VertLine", @TInspector_VertLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VScroll( nWParam, nLParam); oClass:AddMethod( "VScroll", @TInspector_VScroll(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




   _HB_MEMBER VSetPos(); oClass:AddInline( "VSetPos", {|Self, nPos | ( ( Self ) ), ::nVScrollPos := nPos, ::oVScroll:SetPos( iif( ::nLen <= 10000, nPos, Int( nPos * 10000 / ::nLen ) ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER VThumbPos(); oClass:AddInline( "VThumbPos", {|Self, nPos | ( ( Self ) ), ::nVScrollPos := ::VGetThumbPos( nPos ), ::oVScroll:SetPos( nPos ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VGetPos(); oClass:AddInline( "VGetPos", {|Self | ( ( Self ) ), ::nVScrollPos }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )


   _HB_MEMBER VSetRange(); oClass:AddInline( "VSetRange", {|Self | ( ( Self ) ), ::nVScrollPos := 1, ::oVScroll:SetRange( Min( 1, ::nLen ), Min( 10000, ::nLen ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER VGetMax(); oClass:AddInline( "VGetMax", {|Self | ( ( Self ) ), ::oVScroll:nMax * iif( ::nLen <= 10000, 1, ::nLen / 10000 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

   _HB_MEMBER VGoDown(); oClass:AddInline( "VGoDown", {|Self | ( ( Self ) ), ::VSetPos( ::nVScrollPos + 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
   _HB_MEMBER VGoUp(); oClass:AddInline( "VGoUp", {|Self | ( ( Self ) ), ::VSetPos( ::nVScrollPos - 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )



   _HB_MEMBER VGetThumbPos(); oClass:AddInline( "VGetThumbPos", {|Self, nPos | ( ( Self ) ), iif( ::nLen <= 10000, nPos, Int( nPos * ::nLen / 10000 ) ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER VGoBottom(); oClass:AddInline( "VGoBottom", {|Self | ( ( Self ) ), ::VSetPos( ::nLen ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER VGoTop(); oClass:AddInline( "VGoTop", {|Self | ( ( Self ) ), ::VSetPos( 1 ) }, nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )




    _HB_MEMBER wBrwLine( hWnd, hDC, nRowPos, aValues, aColSizes, nColPos, nClrText, nClrPane, hFont, lTree, aJustify, nPressed, nLineStyle, nColAct, lFocused, oVScroll, bLogicLen, lBar); oClass:AddMethod( "wBrwLine", @TInspector_wBrwLine(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER EditData(); oClass:AddMethod( "EditData", @TInspector_EditData(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER SetInspect( oInspect); oClass:AddMethod( "SetInspect", @TInspector_SetInspect(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER ComboLostFocus(); oClass:AddMethod( "ComboLostFocus", @TInspector_ComboLostFocus(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

    _HB_MEMBER DispBegin( lCreateDC); oClass:AddMethod( "DispBegin", @TInspector_DispBegin(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )
    _HB_MEMBER DispEnd( aRestore); oClass:AddMethod( "DispEnd", @TInspector_DispEnd(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) )

oClass:Create() ; ; oInstance := oClass:Instance() ; if __ObjHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; end ; always ; __clsUnlockDef( @s_oClass, oClass ) ; end ; return oInstance ; end ; return s_oClass:Instance() AS CLASS TInspector ;






static FUNCTION TInspector_New( nRow, nCol, nWidth, nHeigth, bLine, aHeaders, aColSizes, oWnd, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, lPixel, bWhen, lDesign, bValid, bLClick, aActions ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector









   If( nRow == nil, nRow := 0, ) ; If( nCol == nil, nCol := 0, ); If( nHeigth == nil, nHeigth := 100, ); If( nWidth == nil, nWidth := 100, ); If( oWnd == nil, oWnd := GetWndDefault(), ); If( oFont == nil, oFont := oWnd:oFont, ); If( nClrFore == nil, nClrFore := 0, ); If( nClrBack == nil, nClrBack := GetSysColor( 5 ), ); If( lUpdate == nil, lUpdate := .F., ); If( cAlias == nil, cAlias := Alias(), ); If( lPixel == nil, lPixel := .F., ); If( lDesign == nil, lDesign := .F., ); If( bValid == nil, bValid := {||.T.}, );




   ::aProperties := {"nTop","nLeft","nBottom","nRight","nClrPane","nClrText","nColPos","nId","lAutoEdit","nHLine","lCellStyle","cAlias"}
   ::cCaption   = ""
   ::nTop       = nRow * If( lPixel, 1, 14 )
   ::nLeft      = nCol * If( lPixel, 1, 8 )
   ::nBottom    = ::nTop + nHeigth - 1
   ::nRight     = ::nLeft + nWidth - 1
   ::oWnd       = oWnd
   ::lHitTop    = .F.
   ::lHitBottom = .F.
   ::lFocused   = .F.
   ::lCaptured  = .F.
   ::lMChange   = .T.
   ::nRowPos    = 1
   ::nColPos    = 1
   ::nColAct    = 1


   ::nStyle     = nOr( 1073741824, 2097152, 1048576, 268435456, 65536, If( lDesign, 67108864, 0 ) )
   ::nId        = ::GetNewId()
   ::cAlias     = cAlias
   ::bLine      = bLine
   ::lAutoEdit  = .F.
   ::lAutoSkip  = .F.
   ::lIconView  = .F.
   ::lCellStyle = .F.
   ::nIconPos   = 0
   ::nHLine     := 30
   ::SetFilter( cField, uVal1, uVal2 )

   ::bAdd       = { || ( ::cAlias )->( DbAppend() ), ::UpStable() }

   ::aHeaders   = aHeaders
   ::aColSizes  = aColSizes
   ::nLen       = 0
   ::lDrag      = lDesign
   ::lCaptured  = .F.
   ::lMChange   = .T.
   ::bChange    = bChange
   ::bLClicked  = bLClick
   ::bLDblClick = bLDblClick
   ::bRClicked  = bRClick

   ::oCursor    = oCursor


   ::nLineStyle    := 2
   ::nClrBackHead  := GetSysColor( 15 )
   ::nClrForeHead  := GetSysColor( 18 )
   ::nClrBackFocus := GetSysColor( 13 )
   ::nClrForeFocus := 16777215

   ::cMsg          = cMsg
   ::lUpdate       = lUpdate
   ::bWhen         = bWhen
   ::bValid        = bValid
   ::aActions      = aActions
   ::nVScrollPos   = 0
   ::lEditing      = .F.

   ::SetColor( nClrFore, nClrBack )





   ::Register( nOr( 1, 2, 8 ) )


   if ! Empty( oWnd:hWnd )
      ::Create()
      if oFont <> nil
         ::SetFont( oFont )
      endif
      ::Default()
      ::lVisible = .T.
      oWnd:AddControl( Self )
   else
      ::oFont := oFont
      oWnd:DefControl( Self )
      ::lVisible = .F.
   endif

   if lDesign
      ::CheckDots()
   endif

return Self






static FUNCTION TInspector_ReDefine( nId, bLine, oDlg, aHeaders, aColSizes, cField, uVal1, uVal2, bChange, bLDblClick, bRClick, oFont, oCursor, nClrFore, nClrBack, cMsg, lUpdate, cAlias, bWhen, bValid, bLClick, aActions ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector


   If( oDlg == nil, oDlg := GetWndDefault(), ) ; If( nClrFore == nil, nClrFore := 0, ); If( nClrBack == nil, nClrBack := GetSysColor( 5 ), ); If( lUpdate == nil, lUpdate := .F., ); If( cAlias == nil, cAlias := Alias(), );

   ::lHitTop    = .F.
   ::lHitBottom = .F.
   ::lFocused   = .F.
   ::nId        = nId
   ::nRowPos    = 1
   ::nColPos    = 1
   ::nColAct    = 1
   ::cAlias     = cAlias
   ::oWnd       = oDlg
   ::aHeaders   = aHeaders
   ::aColSizes  = aColSizes
   ::nClrPane   = 12632256
   ::nClrText   = 16777215
   ::nLen       = 0
   ::lDrag      = .F.
   ::lCaptured  = .F.
   ::lVisible   = .F.
   ::lCaptured  = .F.
   ::lMChange   = .T.

   ::bLine      = bLine
   ::bChange    = bChange
   ::bLClicked  = bLClick
   ::bLDblClick = bLDblClick
   ::bRClicked  = bRClick

   ::oCursor    = oCursor
   ::oFont      = oFont

   ::nLineStyle    := 2

   ::nClrBackHead  := GetSysColor( 15 )
   ::nClrForeHead  := 0
   ::nClrBackFocus := GetSysColor( 13 )
   ::nClrForeFocus := 16777215

   ::cMsg          = cMsg
   ::lUpdate       = lUpdate
   ::bWhen         = bWhen
   ::bValid        = bValid
   ::aActions      = aActions
   ::lAutoEdit     = .F.
   ::lAutoSkip     = .F.
   ::lIconView     = .F.
   ::lCellStyle    = .F.
   ::nIconPos      = 0
   ::nVScrollPos   = 0

   ::SetColor( nClrFore, nClrBack )

   ::SetFilter( cField, uVal1, uVal2 )
   ::bAdd       = { || ( ::cAlias )->( DbAppend() ), ::UpStable() }

   ::Register( nOr( 1, 2, 8 ) )

   oDlg:DefControl( Self )

return Self





static FUNCTION TInspector_DrawSelect( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector
















      ::wBrwLine( ::hWnd, ::hDC, ::nRowPos, Eval( ::bLine, Self ), ::GetColSizes(), ::nColPos, ::nClrForeFocus, If( ::lFocused, ::nClrBackFocus, 8421504 ), If( ::oFont <> nil, ::oFont:hFont, 0 ), ValType( ::aColSizes ) == "B", ::aJustify,, ::nLineStyle, nil, ::lFocused, ::oVScroll, ::bLogicLen, .T. )





return nil



static FUNCTION TInspector_DrawIcons( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nWidth := ::nWidth(), nHeight := ::nHeight()
   local nRow := 10, nCol := 10
   local n := 1, nIcons := Int( nWidth / 50 ) * Int( nHeight / 50 )
   local hIcon := ExtractIcon( "user.exe", 0 )
   local oFont, cText

   oFont := TFont():New( GetSysFont(), 0, -8,,,,,,, .T.,,,,,,, )

   SelectObject( ::hDC, oFont:hFont )
   SetBkColor( ::hDC, 8388608 )
   SetTextColor( ::hDC, 16777215 )

   while n <= nIcons .AND. ! ( ::cAlias )->( EoF() )
      if ::bIconDraw <> nil .AND. ::aIcons <> nil
         hIcon = ::aIcons[ Eval( ::bIconDraw, Self ) ]
      endif
      DrawIcon( ::hDC, nRow, nCol, hIcon )
      if ::bIconText <> nil
         cText = cValToChar( Eval( ::bIconText, Self ) )
      else
         cText = Str( ( ::cAlias )->( RecNo() ) )
      endif
      DrawText( ::hDC, cText, { nRow + 35, nCol - 5, nRow + 48, nCol + 40 }, 1 )
      nCol += 50
      if nCol >= nWidth - 32
         nRow += 50
         nCol  = 10
      endif
      ( ::cAlias )->( DbSkip() )
      n++
   end
   ( ::cAlias )->( DbSkip( 1 - n ) )

   oFont:End()

return nil



static FUNCTION TInspector_Edit( nCol, lModal ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local uTemp, cType, lAutoSave, lContinue

   If( nCol == nil, nCol := 1, ) ; If( lModal == nil, lModal := .T., );

   while .T.
      uTemp = Eval( ::bLine, Self )[ nCol ]
      if ! Empty( ::cAlias ) .AND. Upper( ::cAlias ) <> "ARRAY"
         lAutoSave = ( cValToChar( ( ::cAlias )->( FieldGet( nCol ) ) ) == uTemp )
         if ( ::cAlias )->( RLock() )
            if lContinue := ::lEditCol( nCol, @uTemp )
               if lAutoSave
                  cType = ValType( ( ::cAlias )->( FieldGet( nCol ) ) )
                  do case
                     case cType == "D"
                        ( ::cAlias )->( FieldPut( nCol, CToD( uTemp ) ) )

                     case cType == "L"
                        ( ::cAlias )->( FieldPut( nCol, Upper( uTemp ) == ".T." ) )

                     case cType == "N"
                        ( ::cAlias )->( FieldPut( nCol, Val( uTemp ) ) )

                     otherwise
                        ( ::cAlias )->( FieldPut( nCol, uTemp ) )
                  endcase
               endif
               ::DrawSelect()
            endif
            ( ::cAlias )->( DbUnLock() )
         else
            MsgStop( "Record locked!", "Please, try again" )
         endif
      else
         ::lEditCol( nCol, @uTemp )
      endif
      if lContinue .AND. ::lAutoSkip
         if nCol < Len( Eval( ::bLine, Self ) )
            ::GoRight()
            nCol++
         else
            ::nColPos = 1
            nCol = 1
            ::GoDown()
         endif
      endif
   if ! ( ::lAutoSkip .AND. lContinue ); exit; end; end

return nil



static FUNCTION TInspector_ReSize( nSizeType, nWidth, nHeight ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector
local aC := GetClientRect( ::hWnd )
local nWC := aC[4]-aC[2]
local nW := ::aColSizes[1]+::aColSizes[2]

   ::nRowPos = Min( ::nRowPos, Max( ::nRowCount(), 1 ) )


return ::TControl:ReSize( nSizeType, nWidth, nHeight )



static FUNCTION TInspector_SetArray( aArray ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   ::nAt       = 1
   ::cAlias    = "ARRAY"

   ::bLogicLen = { || ::nLen := Len( aArray ) }
   ::bGoTop    = { || ::nAt := 1 }
   ::bGoBottom = { || ::nAt := Eval( ::bLogicLen, Self ) }


   ::bSkip     = { | nSkip, nOld | nOld := ::nAt, ::nAt += nSkip, ::nAt := Min( Max( ::nAt, 1 ), Eval( ::bLogicLen, Self ) ), ::nAt - nOld }
return nil



static FUNCTION TInspector_SetTree( oTree ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local oItem := oTree:oFirst

   ::lMChange   = .F.
   ::bLine      = { || oItem:GetLabel() }
   ::aColSizes  = { || oItem:ColSizes() }
   ::bGoTop     = { || oItem := oTree:oFirst }
   ::bGoBottom  = { || oItem := oTree:GetLast() }
   ::bSkip      = { | n | oItem := oItem:Skip( @n ), ::Cargo := oItem, n }
   ::bLogicLen  = { || ::nLen := oTree:nCount() }

   ::bLDblClick = { || If( oItem:oTree <> nil, ( oItem:Toggle(), ::Refresh() ),) }
   ::Cargo      = oItem

   ::bKeyChar   = { | nKey | If( nKey == 13 .AND. oItem:oTree <> nil, ( oItem:Toggle(), ::Refresh() ),) }

   if ::oHScroll <> nil
      ::oHScroll:SetRange( 0, 0 )
      ::oHScroll = nil
   endif

   oTree:Draw()

return nil



static FUNCTION TInspector_Paint( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local n := 1, nSkipped := 1, nLines
   local aInfo := ::DispBegin()

   FillRect( ::hDC, GetClientRect( ::hWnd ), ::oBrush:hBrush )

   if ::lIconView
      ::DrawIcons()
      return 0
   endif


   if ::nRowPos == 1 .AND. ! Empty( ::cAlias ) .AND.  Upper( ::cAlias ) <> "ARRAY"
      if ! ( ::cAlias )->( EoF() )
         ( ::cAlias )->( DbSkip( -1 ) )
         if ! ( ::cAlias )->( BoF() )
            ( ::cAlias )->( DbSkip() )
         endif
      endif
   endif



   ::wBrwLine( ::hWnd, ::hDC, 0, ::aHeaders, ::GetColSizes(), ::nColPos, ::nClrForeHead, ::nClrBackHead, If( ::oFont <> nil, ::oFont:hFont, 0 ), .F., ::aJustify, nil, ::nLineStyle,,, ::oVScroll, ::bLogicLen )

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) > 0

      ::Skip( 1 - ::nRowPos )


         nLines = ::nRowCount()
         while n <= nLines .AND. nSkipped == 1
            ::DrawLine( n )
            nSkipped = ::Skip( 1 )
            if nSkipped == 1
               n++
            endif
         end
         ::Skip( ::nRowPos - n )









      if ::nLen < ::nRowPos
         ::nRowPos = ::nLen
      endif

      ::DrawSelect()
   endif

   if ! Empty( ::cAlias ) .AND. Upper( ::cAlias ) <> "ARRAY"
      ::lHitTop    = ( ::cAlias )->( BoF() )
      ::lHitBottom = ( ::cAlias )->( EoF() )
   endif
   ::DispEnd( aInfo )

return 0




static FUNCTION TInspector_lEditCol( nCol, uVar, cPicture, bValid, nClrFore, nClrBack, aItems, bAction ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local oDlg, oGet, oFont, oBtn, oBtnAction
   local nWidth := ::aColSizes[ nCol ]
   local uTemp
   local aDim
   local lOk
   local cType



   If( nClrFore == nil, nClrFore := ::nClrText, ) ; If( nClrBack == nil, nClrBack := ::nClrPane, ); If( nCol == nil, nCol := ::nColAct, );

   uTemp  := uVar
   aDim   := aBrwPosRect( ::hWnd, ::nRowPos, ::aColSizes, ::nColPos, nCol, If( ::oFont <> nil, ::oFont:hFont, 0 ) )



   aDim[ 1 ] = aDim[ 1 ] + 1
   lOk    := .F.
   cType  := ValType( uVar )

   IF ::lCellStyle .AND. nCol <> ::nColAct
        ::nColAct := nCol
         if ::oHScroll <> nil
            ::oHScroll:SetPos(nCol)
         endif
        ::Refresh(.F.)
   ENDIF


   oDlg = TDialog():New( aDim[ 1 ], aDim[ 2 ], aDim[ 3 ], aDim[ 4 ],,,, .F., nOR( 268435456, 2147483648 ),,,,, .T.,,,,,, .F., )

   if ::oFont <> nil

      oFont = TFont():New( ::oFont:cFaceName, ::oFont:nInpWidth, ::oFont:nInpHeight, .F., ::oFont:lBold )
   endif




   do case
      case cType == "L"
           If( aItems == nil, aItems := { ".T.", ".F." }, ) ;
           uVar = If( uTemp, aItems[ 1 ], aItems[ 2 ] )



           oGet := TComboBox():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, ( aDim[ 4 ] - aDim[ 2 ] ) * 0.50, 50, oDlg,, {|Self|( oDlg:End(), lOk := .T. )},, nClrFore, nClrBack, .F., oFont,, .F.,, .F.,,,,, )

      case aItems <> nil



           oGet := TComboBox():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, aItems, ( aDim[ 4 ] - aDim[ 2 ] ) * 0.50, 50, oDlg,, {|Self|( oDlg:End(), lOk := .T. )},, nClrFore, nClrBack, .F., oFont,, .F.,, .F.,,,,, )

      otherwise



         oGet := TGet():New( 0, 0, { | u | If( PCount()==0, uVar, uVar:= u ) }, oDlg, aDim[ 4 ] - aDim[ 2 ] - If( bAction <> nil, 12, 0 ), aDim[ 3 ] - aDim[ 1 ],,, nClrFore, nClrBack, oFont, .F.,, .F.,, .F.,, .F., .F.,, .F., .F., .F.,, .F.,,,,,,, "uVar", )

         oGet:oGet:Picture = cPicture

         if bAction <> nil
            oBtnAction := TButton():New( 0, 0, "", oDlg,, 12, 12,,, .F., .F., .F.,, .F.,,, .F. )

            oBtnAction:bAction = { || oGet:VarPut( Eval( bAction, uVar, Self ) ), oDlg:End(), lOk := .T.  }
         endif
   endcase

   oGet:bValid = bValid

   oBtn := TButton():New( 10, 0, "", oDlg, {|| ( oDlg:End(), lOk := .T. )},,,,, .T., .F., .F.,, .F.,,, .F. )


   oDlg:Activate( oDlg:bLClicked, oDlg:bMoved, oDlg:bPainted, .F.,,, {|Self|DlgAdjust( oDlg, oGet, oBtnAction, aDim, cType )}, oDlg:bRClicked,,, )

   if ! lOk
      uVar = uTemp
   else
      if cType == "L"
         uVar = ( uVar == aItems[ 1 ] )
      endif
   endif

return lOk






static function DlgAdjust( oDlg, oGet, oBtnAction, aDim, cType )


   oDlg:Move( aDim[ 1 ] + 1, aDim[ 2 ] + 1, aDim[ 4 ] - aDim[ 2 ], aDim[ 3 ] - aDim[ 1 ] )

   do case
      case cType == "L"
           oGet:Move( -3, -1, aDim[ 4 ] - aDim[ 2 ] + 3, 50 )

      case oBtnAction <> nil

           oGet:Move( -3, -1, aDim[ 4 ] - aDim[ 2 ] - 14, aDim[ 3 ] - aDim[ 1 ] + 6 )

           oBtnAction:Move( 0, aDim[ 4 ] - aDim[ 2 ] - 15, 15, aDim[ 3 ] - aDim[ 1 ] )

    otherwise
           oGet:Move( -2, 0 )
   endcase

return nil



static FUNCTION TInspector_GoUp( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nLines := ::nRowCount()

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitTop
      ::DrawLine()
      if ::Skip( -1 ) == -1
         ::lHitBottom = .F.
         if ::nRowPos > 1
            ::nRowPos--
         else
            WBrwScroll( ::hWnd, -1, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::nHLine )
         endif
      else
         ::lHitTop = .T.
      endif
      ::DrawSelect()
      if ::oVScroll <> nil
         ::VGoUp()
      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   endif

return nil



static FUNCTION TInspector_GoDown( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nLines := ::nRowCount()

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitBottom
      ::DrawLine()
      if ::Skip( 1 ) == 1
         ::lHitTop = .F.
         if ::nRowPos < nLines
            ::nRowPos++
         else
            WBrwScroll( ::hWnd, 1, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::nHLine )
         endif
      else
         ::lHitBottom = .T.
      endif
      ::DrawSelect()
      if ::oVScroll <> nil
         ::VGoDown()
      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   endif

return nil



static FUNCTION TInspector_GoLeft( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   if ::nColAct > 1
      if ::lCellStyle .AND. ::IsColVisible( ::nColAct-1 )
         ::nColAct--
         ::DrawSelect()
      else
         ::nColPos--
         ::nColAct--
         ::Refresh()
      endif
      if ::oHScroll <> nil
         ::oHScroll:GoUp()
      endif
   endif

return nil



static FUNCTION TInspector_GoRight( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local lColVisible

   if ::nColAct < Len( ::GetColSizes() )
      lColVisible = ::IsColVisible( ::nColAct + 1 )
      ::nColAct++
      while ! ::IsColVisible( ::nColAct ) .AND. ::nColPos < ::nColAct
         ::nColPos++
      enddo
      if ! ::lCellStyle
         ::nColPos := ::nColAct
         ::Refresh()
      else
         if lColVisible
            ::DrawSelect()
         else
            ::Refresh()
         endif
      endif
      if ::oHScroll <> nil
         ::oHScroll:GoDown()
      endif
   endif

return nil



static FUNCTION TInspector_GoTop( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitTop
      Eval( ::bGoTop, Self )
      ::lHitTop = .T.
      ::lHitBottom = .F.
      ::nRowPos = 1
      ::Refresh( .F. )
      if ::oVScroll <> nil
         ::VGoTop()
      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   endif

return nil



static FUNCTION TInspector_GoBottom( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nSkipped
   local nLines := ::nRowCount()
   local n

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitBottom
      ::lHitBottom = .T.
      ::lHitTop    = .F.

      Eval( ::bGoBottom, Self )

      nSkipped = ::Skip( -( nLines - 1 ) )
      ::nRowPos = 1 - nSkipped

      ::GetDC()
      for n = 1 to -nSkipped
          ::DrawLine( n )
          ::Skip( 1 )
      next
      ::DrawSelect()
      ::ReleaseDC()
      if ::oVScroll <> nil
         ::nLen = Eval( ::bLogicLen, Self )
         if ::VGetMax() <> ::nLen
            ::VSetRange()
         endif
         ::VGoBottom()
      endif
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   endif

return nil




static FUNCTION TInspector_LDblClick( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector


   local nClickRow := nWRowEx( ::hWnd, ::hDC, nRow, If( ::oFont <> nil, ::oFont:hFont, 0 ), ::nHLine )
   local nBrwCol

   if nClickRow == ::nRowPos .AND. ::nLen > 0
      ::EditData()
   endif

return nil



function nWRowEx( hWnd, hDC, nRow, oFont, nHLine )
local aRect := GetClientRect( hWnd )

nRow := int( nRow/nHLine)

return nRow

static FUNCTION TInspector_LButtonDown( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nClickRow, nSkipped
   local nColPos := 0, nColInit := ::nColPos - 1
   local nAtCol
   local bInspect := nil
   local aRect
   local nColor
   local o := self
   local cData

   if ::lDrag
      return ::TControl:LButtonDown( nRow, nCol, nKeyFlags )
   endif

   SetFocus(::hwnd)

   nClickRow = nWRowEx( ::hWnd, ::hDC, nRow, If( ::oFont <> nil, ::oFont:hFont, 0 ),::nHline )

   if ::nLen < 1 .AND. nClickRow <> 0
      return nil
   endif





   if ::lMChange .AND. AScan( ::GetColSizes(), { | nColumn | nColPos += nColumn, nColInit++, nCol >= nColPos - 1 .AND.  nCol <= nColPos + 1 }, ::nColPos ) <> 0
      if ! ::lCaptured
         ::lCaptured = .T.
         ::Capture()
         ::VertLine( nColPos, nColInit )
      endif
      return nil
   endif

   ::SetFocus()

   if nClickRow == 0 .AND. Valtype(nKeyFlags) == "N"

      if ::aActions <> nil .AND.  ( nAtCol := ::nAtCol( nCol ) ) <= Len( ::aActions )
            if ::aActions[ nAtCol ] <> nil



               ::wBrwLine( ::hWnd, ::GetDC(), 0, ::aHeaders, ::GetColSizes(), ::nColPos, ::nClrForeHead, ::nClrBackHead, If( ::oFont <> nil, ::oFont:hFont, 0 ),.F., ::aJustify, nAtCol, ::nLineStyle,,, ::oVScroll, ::bLogicLen )
               ::ReleaseDC()
               Eval( ::aActions[ nAtCol ], Self, nRow, nCol )



               ::wBrwLine( ::hWnd, ::GetDC(), 0, ::aHeaders, ::GetColSizes(), ::nColPos, ::nClrForeHead, ::nClrBackHead, If( ::oFont <> nil, ::oFont:hFont, 0 ),.F., ::aJustify,, ::nLineStyle,,, ::oVScroll, ::bLogicLen )
               ::ReleaseDC()
            else
               MsgBeep()
            endif
      else
         MsgBeep()
      endif
   endif

   if nClickRow > 0 .AND. nClickRow <> ::nRowPos .AND. nClickRow < ::nRowCount() + 1

      ::DrawLine()
      nSkipped  = ::Skip( nClickRow - ::nRowPos )
      ::nRowPos += nSkipped
      if ::oVScroll <> nil
         ::VSetPos( ::VGetPos() + nSkipped )
      endif
      if ::lCellStyle
           ::nColAct := ::nAtCol( nCol )
           if ::oHScroll <> nil
              ::oHScroll:SetPos(::nColAct)
           endif
      endif
      ::DrawSelect()
      ::lHitTop = .F.
      ::lHitBottom = .F.
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif
   else

      if PtInRect( nRow, nCol, ::aRectBtn )
         if ::oInspect <> nil
            cData    := ::oInspect:Property( ::nAt )
            bInspect := ::oInspect:Inspect( cData, o )
            if bInspect <> nil
               if valtype( bInspect ) == "A"
                  ::EditData()
               else
                  eval( bInspect, cData, self )
               endif
            endif
         endif
      endif

      if ::lCellStyle
           ::nColAct := ::nAtCol( nCol )
           if ::oHScroll <> nil
              ::oHScroll:SetPos(::nColAct)
           endif
           ::Refresh(.F.)
      endif
   endif

   ::TControl:LButtonDown( nRow, nCol, nKeyFlags )

return 0



static FUNCTION TInspector_LButtonUp( nRow, nCol, nFlags ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector
local aC := GetClientRect( ::hWnd )
local nWC := aC[4]-aC[2]
local nW := ::aColSizes[1]+::aColSizes[2]

   if ::lDrag
      return ::TControl:LButtonUp( nRow, nCol, nFlags )
   endif

   if ::lCaptured
      ::lCaptured = .F.
      ReleaseCapture()

      ::VertLine()
      ::Refresh()
   endif

   ::TControl:LButtonUp( nRow, nCol, nFlags )

return nil



static FUNCTION TInspector_Default( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local n, aFields
   local cAlias := Alias()
   local nElements, nTotal := 0

   If( ::aHeaders == nil, ::aHeaders := {}, ) ; If( ::aColSizes == nil, ::aColSizes := {}, );

   if ::bLine == nil
      if Empty( ::cAlias )
         ::cAlias = cAlias
      else
         cAlias = ::cAlias
      endif
      ::bLine  = { || _aFields( Self ) }
      if ::aJustify == nil
         ::aJustify = Array( nElements := Len( Eval( ::bLine, Self ) ) )
         for n = 1 to nElements
             ::aJustify[ n ] = ( ValType( ( cAlias )->( FieldGet( n ) ) ) == "N" )
         next
      endif
   endif

   If( nElements == nil, nElements := Len( Eval( ::bLine, Self ) ), ) ;

   if Len( ::aHeaders ) < nElements
      if ::Cargo == nil
         ::aHeaders = Array( nElements )
         for n = 1 to nElements
             ::aHeaders[ n ] = ( cAlias )->( FieldName( n ) )
         next
      else
         ::aHeaders = { "" }
      endif
   endif

   if Len( ::GetColSizes() ) < nElements
      ::aColSizes = Afill(Array( nElements ), 0 )
      aFields = Eval( ::bLine, Self )
      for n = 1 to nElements





          ::aColSizes[ n ] := If( ValType( aFields[ n ] ) <> "C", 15, GetTextWidth( 0, Replicate( "B",  Max( Len( ::aHeaders[ n ] ),  Len( aFields[ n ] ) ) + 1 ), If( ! Empty( ::oFont ), ::oFont:hFont,) ) )
      next
   endif


   if lAnd( GetWindowLong( ::hWnd, -16 ), 2097152 ) .OR.  GetClassName( ::hWnd ) == "ListBox"
      ::oVScroll := TScrollBar():WinNew(,,, (!.F.) .OR. .T., Self,,,,,,,,, .F.,, )
      ::nLen := Eval( ::bLogicLen, Self )
      ::oVScroll:SetPage( Min( ::nRowCount(), ::nLen - 1 ) )
      ::VSetRange()
   endif

   if lAnd( GetWindowLong( ::hWnd, -16 ), 1048576 )
      if ::Cargo == nil

         ::oHScroll := TScrollBar():WinNew( 1, Len( ::GetColSizes() ),, (!.T.), Self,,,,,,,,, .F.,, )
         AEval( ::GetColSizes(), { | nSize | nTotal += nSize } )
         ::oHScroll:SetPage( nTotal / ::nWidth() )
      endif
   endif

   if ::uValue1 <> nil
      Eval( ::bGoTop, Self )
   endif
   if ::bChange <> nil
      Eval( ::bChange, Self )
   endif

return nil



static FUNCTION TInspector_KeyDown( nKey, nFlags ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector
local cData, bInspect
local o := self

   do case
      case nKey == 32
           if ::oInspect <> nil
              cData    := ::oInspect:Property( ::nAt )
              bInspect := ::oInspect:Inspect( cData, o )
              if bInspect <> nil
                 eval( bInspect, cData, o )
                 SetFocus( ::hWnd )
              endif
           endif

      case nKey == 38
           ::GoUp()

      case nKey == 40
           ::GoDown()

      case nKey == 37
           ::GoLeft()

      case nKey == 39
           ::GoRight()

      case nKey == 36
           ::GoTop()

      case nKey == 35
           ::GoBottom()

      case nKey == 33
           if GetKeyState( 17 )
              ::GoTop()
           else
              ::PageUp()
           endif

      case nKey == 34
           if GetKeyState( 17 )
              ::GoBottom()
           else
              ::PageDown()
           endif

      otherwise
           return ::TControl:KeyDown( nKey, nFlags )
   endcase

return 0



static FUNCTION TInspector_KeyChar( nKey, nFlags ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   do case
      case nKey == 18
           ::oVScroll:PageUp()

      case nKey == 3
           ::oVScroll:PageDown()

      otherwise
           return ::TControl:KeyChar( nKey, nFlags )
   endcase

return 0



static FUNCTION TInspector_PageUp( nLines ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nSkipped

   If( nLines == nil, nLines := ::nRowCount(), ) ;

   nSkipped = ::Skip( -nLines )

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitTop
      if nSkipped == 0
         ::lHitTop = .T.
      else
         ::lHitBottom = .F.
         if -nSkipped < nLines
            ::nRowPos = 1
            if ::oVScroll <> nil
               ::VSetPos( 1 )
            endif
         else

            nSkipped = ::Skip( -nLines )
            ::Skip( -nSkipped )

            if ::oVScroll <> nil
               ::VSetPos( ::VGetPos() + nSkipped )
            endif

         endif
         ::Refresh( .F. )
         if ::bChange <> nil
            Eval( ::bChange, Self )
         endif

      endif

   else
      if ::oVScroll <> nil
         ::VGoTop()
      endif
   endif

return nil



static FUNCTION TInspector_PageDown( nLines ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nSkipped, n

   If( nLines == nil, nLines := ::nRowCount(), ) ;

   if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
      return nil
   endif

   if ! ::lHitBottom
      ::DrawLine()
      nSkipped = ::Skip( ( nLines * 2 ) - ::nRowPos )

      if nSkipped <> 0
         ::lHitTop = .F.
      endif

      do case
         case nSkipped == 0 .OR. nSkipped < nLines
              if nLines - ::nRowPos < nSkipped
                 ::GetDC()
                 ::Skip( -( nLines ) )
                 for n = 1 to ( nLines - 1 )
                     ::Skip( 1 )
                     ::DrawLine( n )
                 next
                 ::ReleaseDC()
                 ::Skip( 1 )
              endif
              ::nRowPos = Min( ::nRowPos + nSkipped, nLines )
              ::lHitBottom = .T.
              if ::oVScroll <> nil
                 ::VGoBottom()
              endif

         otherwise
              ::GetDC()
              for n = nLines to 1 step -1
                  ::DrawLine( n )
                  ::Skip( -1 )
              next
              ::ReleaseDC()
              ::Skip( ::nRowPos )
      endcase
      ::DrawSelect()
      if ::bChange <> nil
         Eval( ::bChange, Self )
      endif

      if ::oVScroll <> nil
         if ! ::lHitBottom
            ::VSetPos( ::VGetPos() + nSkipped - ( nLines - ::nRowPos ) )
         else
            ::VGoBottom()
         endif
      endif
   endif

return nil



static FUNCTION TInspector_VScroll( nWParam, nLParam ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nLines := ::nRowCount()
   local nLen






      local nScrHandle  := nLParam
      local nScrollCode := nLoWord( nWParam )
      local nPos        := nHiWord( nWParam )


   if GetFocus() <> ::hWnd
      SetFocus( ::hWnd )
   endif

   if nScrHandle == 0
      if ::oVScroll <> nil
                  do case
                  case nScrollCode == 0
                          ::GoUp()

                  case nScrollCode == 1
                          ::GoDown()

                  case nScrollCode == 2
                          ::PageUp()

                  case nScrollCode == 3
                          ::PageDown()

                  case nScrollCode == 6
                          ::GoTop()

                  case nScrollCode == 7
                          ::GoBottom()

                  case nScrollCode == 4
               if ( ::nLen := Eval( ::bLogicLen, Self ) ) < 1
                          return 0
                          endif

               if nPos <= 1
                          ::GoTop()
                          elseif nPos == ::oVScroll:GetRange()[ 2 ]
                          ::GoBottom()
                          else
                          CursorWait()
                  ::Skip( ::VGetThumbPos( nPos ) - ::VGetPos() )
                          ::lHitTop = .F.
                          ::lHitBottom = .F.
                          CursorArrow()
                          endif
               ::VThumbPos( nPos )

               nLen = Eval( ::bLogicLen, Self )
                          if nPos - ::oVScroll:nMin < nLines
                          ::nRowPos = 1
                          endif
                          if ::oVScroll:nMax - nPos < Min( nLines, nLen )
                          ::nRowPos = Min( nLines, nLen ) - ( ::oVScroll:nMax - nPos )
                          endif
                          ::Refresh( .F. )
                          if ::bChange <> nil
                          Eval( ::bChange, Self )
                          endif

                  otherwise
                          return nil
                          endcase
                          endif
                  endif

return 0



static FUNCTION TInspector_HScroll( nWParam, nLParam ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nCol := ::nColPos






      local nScrHandle  := nLParam
      local nScrollCode := nLoWord( nWParam )
      local nPos        := nHiWord( nWParam )


   if ::oGet <> nil .AND. ! Empty( ::oGet:hWnd )
      ::oGet:End()
   endif

   do case
      case nScrollCode == 0
           ::GoLeft()

      case nScrollCode == 1
           ::GoRight()

      case nScrollCode == 2

           while ::nColPos > 1 .AND.  (::IsColVisible( nCol ) .OR. ::nColPos == nCol)
              ::nColPos--
           end
           ::nColAct := ::nColPos
           ::oHScroll:SetPos( ::nColAct )
           ::Refresh( .F. )

      case nScrollCode == 3

           while nCol < Len( ::GetColSizes() ) .AND.  (::IsColVisible( nCol ) .OR. ::nColPos == nCol)
              nCol++
           end
           ::nColPos := nCol
           ::nColAct := nCol
           ::oHScroll:SetPos( nCol )
           ::Refresh( .F. )

      case nScrollCode == 6
           ::nColPos = 1
           ::nColAct = 1
           ::oHScroll:SetPos( 1 )
           ::Refresh( .F. )

      case nScrollCode == 7
           ::nColPos = Len( ::GetColSizes() )
           ::nColAct = ::nColPos
           ::oHScroll:SetPos( ::nColPos )
           ::Refresh( .F. )

      case nScrollCode == 4
           ::nColPos = nPos
           ::nColAct = ::nColPos
           ::oHScroll:SetPos( nPos )
           ::Refresh( .F. )

      otherwise
           return nil
   endcase

return 0



static FUNCTION TInspector_Skip( n ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   if ::bSkip <> nil
      return Eval( ::bSkip, n, Self )
   endif

return ( ::cAlias )->( __DbSkipper( n ) )



static function BrwGoBottom( uExpr )

   local lSoftSeek := Set( 9, .T. )

   if ValType( uExpr ) == "C"

      DbSeek( SubStr( uExpr, 1, Len( uExpr ) - 1 ) +  Chr( Asc( SubStr( uExpr, Len( uExpr ) ) ) + 1 ) )
   else
      DbSeek( uExpr + 1 )
   endif
   DbSkip( -1 )

   Set( 9, lSoftSeek )

return nil





static function BuildSkip( cAlias, cField, uValue1, uValue2 )

   local bSkipBlock
   local cType := ValType( uValue1 )

   do case
      case cType == "C"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= '" + uValue1 + "' .and." +  cField + "<= '" + uValue2 + "' }" ) ) ) }

      case cType == "D"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= CToD( '" + DToC( uValue1 ) + "') .and." +  cField + "<= CToD( '" + DToC( uValue2 ) + "') }" ) ) ) }

      case cType == "N"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= " + cValToChar( uValue1 ) + " .and." +  cField + "<= " + cValToChar( uValue2 ) + " }" ) ) ) }

      case cType == "L"


           bSkipBlock = { | n | ( cAlias )->( BrwGoTo( n,  &( "{||" + cField + ">= " + cValToChar( uValue1 ) + " .and." +  cField + "<= " + cValToChar( uValue2 ) + " }" ) ) ) }
   endcase

return bSkipBlock



static function BrwGoTo( n, bWhile )

   local nSkipped := 0, nDirection := If( n > 0, 1, -1 )

   while nSkipped <> n .AND. Eval( bWhile ) .AND. ! EoF() .AND. ! BoF()
      DbSkip( nDirection )
      nSkipped += nDirection
   enddo

   do case
      case EoF()
         DbSkip( -1 )
         nSkipped += -nDirection

      case BoF()
         DbGoTo( RecNo() )
         nSkipped++

      case ! Eval( bWhile )
         DbSkip( -nDirection )
         nSkipped += -nDirection
   endcase

return nSkipped




static FUNCTION TInspector__RecCount( uSeekValue ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nRecNo := ( ::cAlias )->( RecNo() )
   local nRecs  := 1
   local bField := &( "{ || " + ::cField + "}" )

   if ! ( ::cAlias )->( DbSeek( uSeekValue, .T. ) )

      if ( ::cAlias )->( Eval( bField, Self ) ) > ::uValue2  .OR. ( ::cAlias )->( EoF() )
         nRecs := 0
      endif
   endif



   if ::nMaxFilter == nil
      while ::Skip( 1 ) == 1
         nRecs++
      end
   else
      while ::Skip( 1 ) == 1 .AND. nRecs < ::nMaxFilter
         nRecs++
      end
   endif

   ( ::cAlias )->( DbGoTo( nRecNo ) )

return nRecs



static function GenLocal( aArray, nPos )

return { || If( nPos <= Len( aArray ), aArray[ nPos ], "  " ) }

static function GenBlock( bLine, nPos ) ;  return { || Eval( bLine )[ nPos ] }



static FUNCTION TInspector_Report( cTitle, lPreview ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local oRpt
   local nRecNo := If( Upper( ::cAlias ) <> "ARRAY", ( ::cAlias )->( RecNo() ), 0 )
   local aData  := Eval( ::bLine, Self )
   local n
   local nCharWidth

   nCharWidth := GetTextWidth( 0, "B", If( ::oFont <> nil, ::oFont:hFont, 0 ))

   If( cTitle == nil, cTitle := ::oWnd:cTitle, ) ; If( lPreview == nil, lPreview := .T., );

   if lPreview


      oRpt := RptBegin({{|| cTitle}}, {{|| "Date: " + DToC( Date() ) + ", Time: " + Time()}}, {{|| "Page: " + Str( oRpt:nPage, 3 )}}, {}, {}, .F.,,,, .T.,,,,,, )
   else


      oRpt := RptBegin({{|| cTitle}}, {{|| "Date: " + DToC( Date() ) + ", Time: " + Time()}}, {{|| "Page: " + Str( oRpt:nPage, 3 )}}, {}, {}, .F.,,,, .F.,,,,,, )
   endif

   if Empty( oRpt ) .OR. oRpt:oDevice:hDC == 0
      return nil
   else
      Eval( ::bGoTop, Self )
   endif

   if ::aColSizes == nil
      ::aColSizes = Array( Len( aData ) )
      for n = 1 to Len( aData )
         ::aColSizes[ n ] = 80
      next
   else
      if Len( ::aColSizes ) < Len( aData )
         n = Len( ::aColSizes )
         while n++ < Len( aData )
            AAdd( ::aColSizes, 80 )
         end
      endif
   endif

   for n = 1 to Len( aData )
      if ValType( aData[ n ] ) <> "N"


         oRpt:AddColumn( TrColumn():New( { GenLocal( ::aHeaders, n ) },, { GenBlock( ::bLine, n ) }, Int( ::aColSizes[ n ]/ nCharWidth ),,,,,,,,, oRpt ) )
      else


         oRpt:AddColumn( TrColumn():New( { GenLocal( ::aHeaders, n ) },, { { || "   " } }, Int( ::aColSizes[ n ] / nCharWidth ),,,,,,,,, oRpt ) )
      endif
   next
   RptEnd()

   oRpt:bSkip = { || oRpt:Cargo := ::Skip( 1 ) }
   oRpt:Cargo = 1




   oRpt:Activate(, {|| If( Upper( ::cAlias ) == "ARRAY", oRpt:nCounter < Eval( ::bLogicLen, Self ), oRpt:Cargo == 1 )},,,,,,,,,,,, )

   if Upper( ::cAlias ) <> "ARRAY"
      ( ::cAlias )->( DbGoTo( nRecNo ) )
   endif
   ::Refresh()

return nil



static FUNCTION TInspector_UpStable( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nRow   := ::nRowPos
   local nRecNo := ( ::cAlias )->( RecNo() )
   local nRows  := ::nRowCount()
   local n      := 1
   local lSkip  := .T.

   ::nRowPos    = 1
   ::GoTop()
   ::lHitTop    = .F.
   ::lHitBottom = .F.

   while ! ( ::cAlias )->( EoF() )
      if n > nRows
         ( ::cAlias )->( DbGoTo( nRecNo ) )
         ::nRowPos = nRow
         lSkip     = .F.
         exit
      endif
      if nRecNo == ( ::cAlias )->( RecNo() )
         ::nRowPos = n
         exit
      else
         ( ::cAlias )->( DbSkip() )
      endif
      n++
   end

   if lSkip
      ( ::cAlias )->( DbSkip( -::nRowPos ) )
   endif

   if ::bChange <> nil
      Eval( ::bChange, Self )
   endif

return nil



static FUNCTION TInspector_SetFilter( cField, uVal1, uVal2 ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local cIndexType

   If( uVal2 == nil, uVal2 := uVal1, ) ;

   ::cField     = cField
   ::uValue1    = uVal1
   ::uValue2    = uVal2

   if uVal1 <> nil
      cIndexType := ( ::cAlias )->( ValType( &( IndexKey() ) ) )


      if ( ::cAlias )->( ValType( &cField ) ) <> cIndexType .OR.  ValType( uVal1 ) <> cIndexType .OR.  ValType( uVal2 ) <> cIndexType
         MsgAlert( "TInspector SetFilter() types don't match with current Index Key type!" )
      endif
   endif



   if ! Empty( ::cAlias )


      ::bGoTop     = If( uVal1 <> nil, { || ( ::cAlias )->( DbSeek( uVal1, .T. ) ) }, { || ( ::cAlias )->( DbGoTop() ) } )


      ::bGoBottom  = If( uVal2 <> nil, { || ( ::cAlias )->( BrwGoBottom( uVal2 ) ) }, { || ( ::cAlias )->( DbGoBottom() ) } )


      ::bSkip      = If( uVal1 <> nil, BuildSkip( ::cAlias, cField, uVal1, uVal2 ), { | n | ( ::cAlias )->( __DbSkipper( n ) ) } )



      ::bLogicLen  = If( uVal1 <> nil, { || ( ::cAlias )->( Self:RecCount( uVal1 ) ) }, { || ( ::cAlias )->( RecCount() ) } )

      ::nLen       = Eval( ::bLogicLen, Self )

      ::lHitTop    = .F.
      ::lHitBottom = .F.

      if uVal1 <> nil
         Eval( ::bGoTop, Self )
      endif
   else
      ::bLogiclen = { || 0 }
   endif

return nil



static FUNCTION TInspector_MouseMove( nRow, nCol, nKeyFlags ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nColPos := 0

   if ::lDrag
      return ::TControl:MouseMove( nRow, nCol, nKeyFlags )
   endif

   if ::lCaptured
      CursorWE()
      ::VertLine( nCol )
      return 0
   endif




   if ::lMChange .AND. AScan( ::GetColSizes(), { | nColumn | nColPos += nColumn, nCol >= nColPos - 1 .AND.  nCol <= nColPos + 1 }, ::nColPos ) <> 0
      CursorWE()
   else
      if !empty( ::aRectBtn ) .AND. PtInRect( nRow, nCol, ::aRectBtn )
         CursorHand()
      else
         ::TControl:MouseMove( nRow, nCol, nKeyFlags )
      endif

   endif

return 0



static FUNCTION TInspector_MouseWheel( nKeys, nDelta, nXPos, nYPos ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local aPos := { nYPos, nXPos }

   aPos = ScreenToClient( ::hWnd, aPos )








      if lAnd( nKeys, 16 )
         if nDelta > 0
            ::PageUp()
         else
            ::PageDown()
         endif
      else
         if nDelta > 0
            ::GoUp()
         else
            ::GoDown()
         endif
      endif


return nil










static FUNCTION TInspector_VertLine( nColPos, nColInit ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local oRect, aSizes, nFor

   static nCol, nWidth, nMin, nOldPos := 0

   if nColInit <> nil
      nCol    = nColInit
      nWidth  = nColPos
      nOldPos = 0
      nMin := 0
      aSizes := ::GetColSizes()

      FOR nFor := ::nColPos TO nColInit - 1
          nMin += aSizes[nFor]
      NEXT

      nMin += 5
   endif

   if nColPos == nil .AND. nColInit == nil
      ::aColSizes[ nCol ] -= ( nWidth - nOldPos )
      ::Refresh()
   endif

   if nColPos <> nil
     nColPos := Max(nColPos, nMin)
   endif

   oRect = ::GetRect()
   ::GetDC()
   if nOldPos <> 0
      InvertRect( ::hDC, { 0, nOldPos - 2, oRect:nBottom, nOldPos + 2 } )
      nOldPos = 0
   endif
   if nColPos <> nil .AND. ( nColPos - 2 ) > 0
      InvertRect( ::hDC, { 0, nColPos - 2, oRect:nBottom, nColPos + 2 } )
      nOldPos = nColPos
   endif
   ::ReleaseDC()

return nil



static FUNCTION TInspector_nAtCol( nColPixel ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nColumn := ::nColPos - 1
   local aSizes  := ::GetColSizes()
   local nPos    := 0

   If( nColPixel == nil, nColPixel := 0, ) ;

   while nPos < nColPixel .AND. nColumn < Len( aSizes )
      nPos += aSizes[ nColumn + 1 ]
      nColumn++
   end

return nColumn



static FUNCTION TInspector_nAtIcon( nRow, nCol ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nIconsByRow := Int( ::nWidth() / 50 )

   nRow -= 9
   nCol -= 1

   if ( nCol % 50 ) >= 9 .AND. ( nCol % 50 ) <= 41
      return Int( ( nIconsByRow * Int( nRow / 50 ) ) + Int( nCol / 50 ) ) + 1
   else
      return 0
   endif

return nil



static FUNCTION TInspector_Display( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nRecs

   ::BeginPaint()
   if ::oVScroll <> nil
      nRecs := Eval( ::bLogicLen, Self )
      if ::VGetMax() <> nRecs .OR. nRecs <> ::nLen
         ::nLen := nRecs
         ::VSetRange()
         ::oVScroll:SetPage( Min( ::nRowCount(), ::nLen - 1 ), .T. )
      endif
   endif
   if ::oHScroll <> nil

      ::oHScroll:SetRange( 0, 0 )
   endif
   ::Paint()
   ::EndPaint()

return 0



static FUNCTION TInspector_GetDlgCode( nLastKey ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector




   if ! ::oWnd:lValidating

      if nLastKey == 38 .OR. nLastKey == 40  .OR. nLastKey == 13 .OR. nLastKey == 9
         ::oWnd:nLastKey = nLastKey
      else
         ::oWnd:nLastKey = 0
      endif
   endif

return If( IsWindowEnabled( ::hWnd ), 4, 0 )



function _aFields( Self )

   local aFld, aSizes, cAlias := ::cAlias
   local nCols, nFirstCol, nLastCol, nWidth, nBrwWidth

   if Empty( cAlias )
      return {}
   endif

   if Len( ::aColSizes ) == 0
      return Array( ( cAlias )->( Fcount() ) )
   endif

  aSizes    = ::aColSizes
  nCols     = Len( aSizes )
  nFirstCol = ::nColPos
  nLastCol  = nFirstCol
  nWidth    = 0
  nBrwWidth = ::nWidth()
  aFld      = Array( nCols )

  AFill( aFld, "" )

  while nWidth < nBrwWidth .AND. nLastCol <= nCols
     nWidth += aSizes[ nLastCol ]
     if ValType( ( cAlias )->( FieldGet( nLastCol ) ) ) == "M"

        aFld[ nLastCol ] = If( ! Empty( ( cAlias )->(  FieldGet( nLastCol ) ) ), "<Memo>", "<memo>" )
        nLastCol++
     else
        aFld[ nLastCol ] = cValToChar( ( cAlias )->( FieldGet( nLastCol ) ) )
        nLastCol++
     endif
  end

return aFld



static FUNCTION TInspector_SetCols( aData, aHeaders, aColSizes ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local aFields
   local nElements, n

   nElements   := Len( aData )

   ::aHeaders  := If( aHeaders  <> nil, aHeaders, ::aHeaders )
   ::aColSizes := If( aColSizes <> nil, aColSizes, {} )
   ::bLine     := {|| _aData( aData ) }
   ::aJustify  := AFill( Array( nElements ), .F. )

   if Len( ::GetColSizes() ) < nElements
      ::aColSizes = AFill( Array( nElements ), 0 )
      aFields = Eval( ::bLine, Self )
      for n = 1 to nElements





          ::aColSizes[ n ] := If( ValType( aFields[ n ] ) <> "C", 15, GetTextWidth( 0, Replicate( "B",  Max( Len( ::aHeaders[ n ] ),  Len( aFields[ n ] ) ) + 1 ), If( ! Empty( ::oFont ), ::oFont:hFont,) ) )
      next
   endif

   if ::oHScroll <> nil
      ::oHScroll:nMax := ::GetColSizes()
   endif

return nil



static FUNCTION TInspector_ShowSizes( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local cText := ""


   AEval( ::aColSizes, { | v,e | cText += ::aHeaders[ e ] + ": " + Str( v, 3 ) + Chr(13)+Chr(10) } )

   MsgInfo( cText )

return nil



static FUNCTION TInspector__DrawIcon( nIcon, lFocused ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nIconsByRow := Int( ::nWidth() / 50 )
   local nRow := Int( --nIcon / nIconsByRow )
   local nCol := If( nRow > 0, nIcon % ( nRow * nIconsByRow ), nIcon )

   If( lFocused == nil, lFocused := .F., ) ;

   if lFocused

      DrawIconFocus( ::GetDC(), ( nRow * 50 ) + 10, ( nCol * 50 ) + 10, ExtractIcon( "user.exe" ) )
   else

      DrawIcon( ::GetDC(), ( nRow * 50 ) + 10, ( nCol * 50 ) + 10, ExtractIcon( "user.exe" ) )
   endif

return nil



static FUNCTION TInspector_IsColVisible( nCol ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local nCols, nFirstCol, nLastCol, nWidth, nBrwWidth

   nCols     := Len( ::GetColSizes() )
   nFirstCol := ::nColPos
   nLastCol  := nFirstCol
   nWidth    := 0
   nBrwWidth := ::nWidth - If( ::oVScroll <> nil, 16, 0 )

   if nCol < nFirstCol
      return .F.
   endif

   while nWidth < nBrwWidth .AND. nLastCol <= nCol
      nWidth += ::GetColSizes()[ nLastCol ]
      nLastCol++
   end

   if nCol <= --nLastCol


      if nWidth > nBrwWidth
          return .F.
      endif

      return .T.

   endif

return .F.



static function _aData( aFields )

  local aFld
  local nFor, nLen

  nLen = Len( aFields )
  aFld = Array( nLen )

  for nFor = 1 to nLen
     aFld[ nFor ] = Eval( aFields[ nFor ] )
  next

return aFld








static FUNCTION TInspector_wBrwLine( hWnd, hDC, nRowPos, aValues, aColSizes, nColPos, nClrText, nClrPane, hFont, lTree, aJustify, nPressed, nLineStyle, nColAct, lFocused, oVScroll, bLogicLen, lBar ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector
   local nTxtHeight, hOldFont
   local nColStart  := -1
   local nWidth     := GetClientRect(::hWnd)[4]
   local nRow := nRowPos, nTop, nBottom, nLeft, nRight, n
   local lReleaseDC := .F.
   local nForeColor, nBackColor
   local hPen, hOld, hBrush
   local hFontBold, nLenText
   local cData
   local bInspect := nil
   local aRect
   local nColor
   local o := self

   if ::oInspect <> nil
      cData    := ::oInspect:Property( ::nAt )
      bInspect := ::oInspect:Inspect( cData, o )
   endif

   If( lTree == nil, lTree := .F., ) ; If( lBar == nil, lBar := .F., );

   if Empty( hDC )
      hDC = GetDC( hWnd )
      lReleaseDC = .T.
   endif

   hOldFont   = SelectObject( hDC, hFont )

   nTxtHeight = ::nHLine

   nTop    := nTxtHeight * nRow
   nBottom := nTop + nTxtHeight - 1

   SetTextColor( hDC, If( ValType( nClrText ) == "B", nClrText := Eval( nClrText ), nClrText ) )
   SetBkColor  ( hDC, If( ValType( nClrPane ) == "B", nClrPane := Eval( nClrPane ), nClrPane ) )

   for n := nColPos to Len( aValues )

      hOldFont   = SelectObject( hDC, hFont )

      nLeft   := nColStart + 1
      nRight  := Min( nColStart := ( nLeft + aColSizes[ n ] - 1 ), nWidth )
      if nLeft > nWidth
         exit
      endif
      if n == Len( aValues )
         nRight = nWidth
      endif

      if nRowPos == 0




         FillSolidRect( hDC, { nTop, nLeft, nBottom, nRight + If( ( nLineStyle ==  0 .OR. nLineStyle == 8 .OR. nLineStyle ==  7 ) .AND. nRowPos <> 0, 2, 0 ) }, GetBkColor( hDC )  )

      else

         if nColAct <> nil .AND. n == nColAct

            SetTextColor( hDC, nClrText )

            if ::lEditing
               SetBkColor( hDC, ::nClrPane )
            else
               SetBkColor( hDC, nClrPane )
            endif

         else

            if nRowPos <> 0

               if n == 1
                  SetTextColor( hDC, ::nClrText )



                  SetBkColor( hDC, ::nClrPane )

               else
                  SetTextColor( hDC, nClrText )
                  if ::lEditing
                     SetBkColor( hDC, ::nClrPane )
                  else
                     SetBkColor( hDC, nClrPane )
                  endif
               endif

            endif
         endif
      endif

      if aJustify <> nil .AND. aJustify[ n ]






         ExtTextOut( hDC, nTop, nRight - 2, { nTop, nLeft, nBottom, nRight + If( (nLineStyle ==  0 .OR. nLineStyle == 8 .OR.  nLineStyle == 7 ) .AND. nRowPos <> 0, 2, 0 ) }, "" )


         DrawText( hDC, alltrim(cValToChar( aValues[n] )), { nTop, nLeft+3, nBottom, nRight + If( (nLineStyle ==  0 .OR. nLineStyle == 8 .OR.  nLineStyle == 7 ) .AND. nRowPos <> 0, 2, 0 ) }, nOr( 4, 2,32 ) )

      else





         ExtTextOut( hDC, nTop, nLeft + 2, { nTop, nLeft, nBottom, nRight + If( ( nLineStyle ==  0 .OR. nLineStyle == 8 .OR.  nLineStyle == 7 ) .AND. nRowPos <> 0, 2, 0 ) }, "" )


         DrawText( hDC, alltrim( cValToChar( aValues[n] )), { nTop, nLeft+3, nBottom, nRight + If( (nLineStyle ==  0 .OR. nLineStyle == 8 .OR.  nLineStyle == 7 ) .AND. nRowPos <> 0, 2, 0 ) }, nOr( 4, 32768,32 ) )
      endif

      if bInspect <> nil .AND. valtype( bInspect ) == "B" .AND. nClrPane <> ::nClrPane .AND. nRowPos > 0

         nTop    = ::nHLine * nRowPos
         nBottom = nTop + ::nHLine - 1
         nRight := GetClientRect(::hWnd)[4]
         aRect := { nTop, nRight - 20, nBottom+1, nRight }

         DrawFrameControl( hDC, aRect , 4, 16 )

         SetBkMode( hDC, 1 )
         nColor := SetTextColor( hDC, 0 )
         TextOut( hDC, nTop+2, nRight-18, "...")
         SetBkMode( hDC, 0 )
         SetTextColor( hDC, nColor )

         ::aRectBtn := aRect

      endif


      if ! lTree
         if nRowPos == 0
         else
            nLeft += 1
            do case
               case nLineStyle == 1
                    WndBox( hDC, nTop - 1, nLeft - 1, nBottom, nRight )

               case nLineStyle == 2
                    hPen = CreatePen( 0, 1, ( 212 + ( 208 * 256 ) + ( 200 * 65536 ) ) )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 2, nTop - 2 )
                    LineTo( hDC, nLeft - 2, nBottom )
                    LineTo( hDC, nRight , nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )

               case nLineStyle == 3
                    WndBoxRaised( hDC, nTop, nLeft, nBottom, nRight )

               case nLineStyle == 4
                    SetTextColor( hDC, 0 )
                    FrameDot( hDC, nTop - 1, nLeft - 1, nBottom, nRight )

               case nLineStyle == 5
                    hPen = CreatePen( 0, 1, 0 )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 1, nTop - 2 )
                    LineTo( hDC, nLeft - 1, nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )

               case nLineStyle == 6
                    hPen = CreatePen( 0, 1, 8421504 )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 1, nTop - 2 )
                    LineTo( hDC, nLeft - 1, nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )

               case nLineStyle == 7
                    hPen = CreatePen( 0, 1, 0 )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 2, nBottom )
                    LineTo( hDC, nRight , nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )

               case nLineStyle == 8
                    hPen = CreatePen( 0, 1, 8421504 )
                    hOld = SelectObject( hDC, hPen )
                    MoveTo( hDC, nLeft - 2, nBottom )
                    LineTo( hDC, nRight , nBottom )
                    SelectObject( hDC, hOld )
                    DeleteObject( hPen )
            endcase
         endif
      endif

      if nColPos > nWidth
         exit
      endif
      SelectObject( hDC, hOldFont )
      if hFontBold <> nil
         DeleteObject( hFontBold )
      endif

   next



   if lReleaseDC
      ReleaseDC( hWnd, hDC )
   endif

return nil


  static FUNCTION TInspector_EditData( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector



   local cData    := ::oInspect:Property( ::nAt )
   local o := self
   local bInspect := ::oInspect:Inspect( cData, o )
   local aArray   := If( ValType( bInspect ) == "A", bInspect, nil )
   local uTemp    := OSend( ::oInspect, cData )

   If( uTemp == nil, uTemp := "", ) ;

   if ValType( uTemp ) == "C"
      uTemp = PadR( uTemp, 50 )
   endif





   ::EditCol( @uTemp, aArray, bInspect )


return nil


  static FUNCTION TInspector_EditCol( uVar, aArray, bInspect ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector


   local aClient := GetClientRect(::hWnd)
   local aDim
   local aItems
   local aRect
   local bValid := {||.T.}
   local cVar
   local cPicture
   local cType
   local nBottom
   local nHeight
   local nLeft
   local nRight
   local nTop
   local nWidth
   local o := Self
   local oFont
   local uTemp

   uTemp    := uVar
   nTop     := (::nRowPos)*::nHLine+4
   nLeft    := ::aColSizes[1]
   nBottom  := nTop + ::nHLine-6
   nRight   := aClient[4] - if( bInspect <> nil, 20, 0 )
   aDim     := { nTop, nLeft, nBottom, nRight }
   aRect    := { nTop-4, nLeft, nBottom+6, nRight }

   cType   := ValType( uVar )

   if cType == "C"
      uVar := padr(uVar,100)
   endif

   if !empty( aArray )
      cType := "A"
   endif

   If( bValid == nil, bValid := {|| .T. }, ) ;

   ::lEditing := .T.
   ::Refresh()

   if ::oGet <> nil .AND. ! Empty( ::oGet:hWnd )
      ::oGet:End()
   endif

   if ::oFont <> nil
      oFont = TFont():New( ::oFont:cFaceName, ::oFont:nInpWidth,::oFont:nInpHeight, .F., ::oFont:lBold )
   endif

   do case
      case cType == "L" .OR. cType == "A"

           ::nLastKey := 0

           if cType == "L"
              cVar := if( uVar,".T.",".F." )
              aItems := {".T.",".F."}
           else
              cVar   := uVar
              aItems := aArray
           endif

           oFont := TFont():New( "Ms OutLook", 10, aRect[3]- aRect[1]- 8,,,,,,,,,,,,,, )




           ::oGet := TComboBox():New( aRect[1], aRect[2], { | u | If( PCount()==0, cVar, cVar:= u ) }, aItems, aRect[4]-aRect[2], 510, o,,,,,, .T., oFont,, .F.,, .F.,,, 2,, )

           SetFocus( ::oGet:hWnd )

           SendMessage( HWNDCOMBOEDIT( ::oGet:hWnd ), 48, ::oFont:hFont, 0 )
           SendMessage( HWNDCOMBOLIST( ::oGet:hWnd ), 48, ::oFont:hFont, 0 )
           SendMessage( ::oGet:hWnd , 335, 1, 0 )

           uVar := cVar

   ::oGet:oGet:bLostFocus := {|| ::ComboLostFocus( uVar ) }


   ::oGet:bKeyDown := { | nKey | If( nKey == 13 .OR. nKey == 27, ( Self:nLastKey := nKey, SetFocus( o:hWnd ),::lEditing := .F.), ) }
   otherwise






       ::oGet := TGet():New( nTop + 1, nLeft + 1, { | u | If( PCount()==0, uVar, uVar:= u ) }, Self, nRight-nLeft, nBottom-nTop,,, ::nClrText, ::nClrPane, oFont, .F.,, .T.,, .F.,, .F., .F.,, .F., .F., .T.,,,,,,,,, "uVar", )


      ::nLastKey := 0



      ::oGet:SetFocus()

      if Upper( ::oGet:ClassName() ) <> "TGET"
         ::oGet:Refresh()
      endif








      ::oGet:bLostFocus := {|| ( ::oGet:Assign(), ::oGet:VarPut( ::oGet:oGet:VarGet())) , If( Self:nLastKey <> 27, o:oInspect:SetProp(o:oInspect:Property( o:nAt ), o:oGet:VarGet ), ), ::oGet:End(),o:lEditing := .F., SetFocus( o:hWnd )}


      ::oGet:bKeyDown := { | nKey | If( nKey == 13 .OR. nKey == 27, ( Self:nLastKey := nKey, ::oGet:End()), ) }
   endcase

return uVar



    static FUNCTION TInspector_ComboLostFocus( uVar ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector


local uVal

If ::nLastKey == 27
   oSend( ::oInspect,"_" + ::oInspect:Property( ::nAt ), uVar )
else
   ::oGet:VarPut( ::oGet:oGet:VarGet())
   if ::oGet:oGet:VarGet() == ".T." .OR. ::oGet:oGet:VarGet() == ".F."
      oSend( ::oInspect,"_" + ::oInspect:Property( ::nAt ), ::oGet:oGet:VarGet() == ".T." )
   else
      oSend( ::oInspect,"_" + ::oInspect:Property( ::nAt ), ::oGet:VarGet()  )
   endif
   ::oInspect:Refresh()
endif

::oGet:End()

::lEditing := .F.

SetFocus( ::hWnd )

return 0



    static FUNCTION TInspector_SetInspect( oInspect ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

local o := self

   ::oInspect := oInspect

   ::nAt       = 1
   ::bGoTop    = { || ::nAt := 1 }
   ::bGoBottom = { || ::nAt := Eval( ::bLogicLen ) }
   ::bLogicLen = { || If( o:oInspect <> nil, o:oInspect:PropCount(), 0 ) }
   ::bLine     = { || { o:oInspect:Property( ::nAt ), cValToChar( OSend( o:oInspect, o:oInspect:Property( ::nAt ) ) ) } }




   ::bSkip     = { | nSkip, nOld | nOld := ::nAt, ::nAt += nSkip, ::nAt := Min( Max( ::nAt, 1 ), Eval( ::bLogicLen ) ), ::nAt - nOld }
   ::bKeyChar   := { | nKey | If( nKey == 13, o:EditData(),) }
   ::bLDblClick := { | nKey | If( nKey == 13, o:EditData(),) }

   ::Refresh()

return 0

static FUNCTION TInspector_DispBegin( ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector

   local aInfo

      aInfo = FWDispBegin( ::hWnd, ::hDC )
      ::hDC = aInfo[ 3 ]

return aInfo



static FUNCTION TInspector_DispEnd( aRestore ) ; local Self AS CLASS TInspector := QSelf() AS CLASS TInspector


      FWDispEnd( aRestore )
      ::hDC = aRestore[ 2 ]


return nil
